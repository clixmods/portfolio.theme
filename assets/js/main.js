console.log('This site was generated by Hugo.');

// Utility function to convert hex to RGB
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// Initialize tech badge colors
function initializeTechBadgeColors() {
    const techBadges = document.querySelectorAll('.tech-badge[style*="--tech-color"]');
    techBadges.forEach(badge => {
        const style = badge.getAttribute('style');
        const colorMatch = style.match(/--tech-color:\s*([^;]+)/);
        if (colorMatch) {
            const hexColor = colorMatch[1].trim();
            const rgb = hexToRgb(hexColor);
            if (rgb) {
                badge.style.setProperty('--tech-color', hexColor);
                badge.style.setProperty('--tech-color-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            }
        }
    });
}

// Navigation Menu Functionality
document.addEventListener('DOMContentLoaded', function() {
    const navItems = document.querySelectorAll('.nav-item');
    const sections = document.querySelectorAll('section[id]');
    
    // Smooth scrolling for navigation links
    navItems.forEach(navItem => {
        navItem.addEventListener('click', function(e) {
            e.preventDefault();
            
            const targetId = this.getAttribute('href').substring(1);
            const targetSection = document.getElementById(targetId);
            
            if (targetSection) {
                // Update active nav item
                navItems.forEach(item => item.classList.remove('active'));
                this.classList.add('active');
                
                // Smooth scroll to section
                targetSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
    
    // Update active nav item on scroll
    function updateActiveNavOnScroll() {
        let current = '';
        const scrollPosition = window.pageYOffset + 200; // Adjusted offset for better detection
        
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            
            if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                current = section.getAttribute('id');
            }
        });
        
        // If we're at the top of the page, highlight the first section
        if (window.pageYOffset < 100) {
            current = 'profil';
        }
        
        // Update nav items
        navItems.forEach(navItem => {
            navItem.classList.remove('active');
            const href = navItem.getAttribute('href');
            if (href === `#${current}`) {
                navItem.classList.add('active');
            }
        });
    }
    
    // Scroll progress bar function
    function updateScrollProgress() {
        const scrollTop = window.pageYOffset;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = (scrollTop / docHeight) * 100;
        
        const progressBar = document.querySelector('.scroll-progress-bar');
        if (progressBar) {
            progressBar.style.width = scrollPercent + '%';
        }
    }
    
    // Listen for scroll events with throttling for performance
    let scrollTimeout;
    window.addEventListener('scroll', function() {
        if (scrollTimeout) {
            clearTimeout(scrollTimeout);
        }
        scrollTimeout = setTimeout(() => {
            updateActiveNavOnScroll();
            updateScrollProgress();
        }, 10);
    });
    
    // Initial calls
    updateActiveNavOnScroll();
    updateScrollProgress();
});

// Notification system - uses NotificationsManager from notifications-manager.js
// The actual showNotification function is defined in notifications-manager.js
// and exposed globally via window.showNotification

// Expose functions globally for inline onclick handlers
window.openYouTubeModal = openYouTubeModal;
window.closeYouTubeModal = closeYouTubeModal;
window.toggleYouTubeEmbed = toggleYouTubeEmbed;
window.toggleInfoBox = toggleInfoBox;
window.initializeProjectWidgetHandlers = initializeProjectWidgetHandlers;
window.showMoreActions = showMoreActions;
window.hideMoreActions = hideMoreActions;
window.handleYouTubeAction = handleYouTubeAction;
window.extractYouTubeVideoId = extractYouTubeVideoId;
// window.showNotification is now provided by notifications-manager.js

// Projects Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Initialize tech badge colors
    initializeTechBadgeColors();
    
    // Initialize project widget event handlers
    initializeProjectWidgetHandlers();
    
    // Projects tabs using TabController - works for both home page and /projects/ page
    const projectsSection = document.querySelector('.projects-section');
    if (projectsSection) {
        const projectTabs = new TabController('.projects-section .tab-btn', {
            contentSelector: '.projects-section .project-card-wrapper',
            contentAttribute: 'data-category',
            animationType: 'cards',
            animationDuration: 300,
            cardSelector: '.projects-section .project-card-wrapper',
            cardAnimationDelay: 50,
            updateDescription: true,
            descriptionSelector: '#section-description',
            descriptions: window.PROJECT_DESCRIPTIONS || {
                games: "Projets de d√©veloppement de jeux vid√©o, du prototypage √† la production commerciale.",
                "apps-web": "Applications web modernes et solutions full-stack utilisant les derni√®res technologies.",
                "mods-tools": "Outils de d√©veloppement, mods et utilitaires pour am√©liorer les workflows cr√©atifs."
            }
        });
    }

    // Initialize card animations - using unified card classes
    const projectCards = document.querySelectorAll('.project-card-unified');
    projectCards.forEach(card => {
        card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    });
});

// Education Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Education tabs using TabController - scoped to education section to avoid interference
    // Uses simple show/hide to prevent visual overlap issues
    const educationTabs = new TabController('.education-section .tab-btn', {
        contentSelector: '.education-section .timeline-container[data-tab]',
        contentAttribute: 'data-tab',
        animationType: 'none',
        animationDuration: 300
    });

    // Initialize timeline styles
    const timelines = [
        document.getElementById('education-timeline'),
        document.getElementById('certifications-timeline')
    ];
    timelines.forEach(timeline => {
        if (timeline) {
            timeline.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
        }
    });
});

// Experience Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Global flag to prevent double initialization
    if (window.experienceTabsInitialized) {
        return;
    }
    window.experienceTabsInitialized = true;
    
    // Experience tabs using TabController - scoped to experience section to avoid interference
    const experienceSection = document.querySelector('.experience-section');
    
    if (experienceSection) {
        const experienceTabButtons = experienceSection.querySelectorAll('.tab-btn');
        const experienceTimelines = experienceSection.querySelectorAll('.experience-timeline');
        
        if (experienceTabButtons.length > 0 && experienceTimelines.length > 0) {
            const experienceTabs = new TabController('.experience-section .tab-btn', {
                contentSelector: '.experience-section .experience-timeline[data-tab]',
                contentAttribute: 'data-tab',
                animationType: 'none',
                animationDuration: 0
            });
        }
    }

    // Initialize timeline styles
    const expTimelines = [
        document.getElementById('experiences-timeline'),
        document.getElementById('internships-timeline')
    ];
    expTimelines.forEach(timeline => {
        if (timeline) {
            timeline.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
        }
    });
});

// Testimonials Slider - Using CarouselController
document.addEventListener('DOMContentLoaded', function() {
    const slider = document.querySelector('.testimonials-slider');
    if (!slider) return;

    // Initialize carousel with our centralized class
    new CarouselController('.testimonials-slider', {
        autoplayDuration: 5000,
        enableSwipe: true,
        pauseOnHover: true,
        loop: true
    });
});

// Contact Form Functionality
document.addEventListener('DOMContentLoaded', function() {
    const contactForm = document.getElementById('contactForm');
    
    if (contactForm) {
        contactForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Get form data
            const formData = new FormData(contactForm);
            const name = formData.get('name');
            const email = formData.get('email');
            const subject = formData.get('subject');
            const message = formData.get('message');
            
            // Basic validation
            if (!name || !email || !message) {
                showNotification('Veuillez remplir tous les champs requis.', 'error');
                return;
            }
            
            // Email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                showNotification('Veuillez entrer une adresse email valide.', 'error');
                return;
            }
            
            // Show loading state
            const submitBtn = contactForm.querySelector('.submit-btn');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '<span>Envoi en cours...</span><div class="btn-icon">‚è≥</div>';
            submitBtn.disabled = true;
            
            // Simulate form submission (replace with actual form handling)
            setTimeout(() => {
                // Create mailto link as fallback
                const mailtoLink = `mailto:clement.g.developer@gmail.com?subject=${encodeURIComponent(subject || 'Contact depuis le portfolio')}&body=${encodeURIComponent(`Nom: ${name}\nEmail: ${email}\n\nMessage:\n${message}`)}`;
                
                // Open default email client
                window.location.href = mailtoLink;
                
                // Reset form
                contactForm.reset();
                
                // Reset button
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;
                
                // Show success message
                showNotification('Votre message a √©t√© pr√©par√© dans votre client email !', 'success');
            }, 1000);
        });
    }
    
    // Form field animations
    const formInputs = document.querySelectorAll('.contact-form input, .contact-form select, .contact-form textarea');
    
    formInputs.forEach(input => {
        input.addEventListener('focus', function() {
            this.parentElement.classList.add('focused');
        });
        
        input.addEventListener('blur', function() {
            if (!this.value) {
                this.parentElement.classList.remove('focused');
            }
        });
        
        // Check if field has value on page load
        if (input.value) {
            input.parentElement.classList.add('focused');
        }
    });
});

// Notification system handled by notifications-manager.js
// showNotification is exposed globally via window.showNotification from that module

// Project Actions - Show More functionality
// DEPRECATED: Old action popup system - now using unified modal
// Keeping for backward compatibility during transition
function showMoreActions(button) {
    console.warn('showMoreActions is deprecated - use openProjectActionsModal instead');
}

// G√©rer les actions YouTube avec le viewer int√©gr√©
function handleYouTubeAction(url, title) {
    // Ajouter un indicateur de chargement
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'youtube-loading-indicator';
    loadingIndicator.innerHTML = 'üé• Ouverture du viewer...';
    loadingIndicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        z-index: 10001;
        font-size: 14px;
        backdrop-filter: blur(10px);
        animation: fadeIn 0.3s ease;
    `;
    
    document.body.appendChild(loadingIndicator);
    
    try {
        // Extraire l'ID vid√©o de l'URL YouTube
        const videoId = extractYouTubeVideoId(url);
        
        if (videoId) {
            // Fermer d'abord le popup des actions
            hideMoreActions(document.querySelector('.actions-popup'));
            
            setTimeout(() => {
                openYouTubeModal(videoId, title);
                if (loadingIndicator.parentElement) {
                    document.body.removeChild(loadingIndicator);
                }
            }, 500);
        } else {
            console.warn('Cannot extract YouTube video ID from URL:', url, '- opening in new tab');
            if (loadingIndicator.parentElement) {
                document.body.removeChild(loadingIndicator);
            }
            
            // Fallback: ouvrir dans un nouvel onglet
            setTimeout(() => window.open(url, '_blank'), 300);
        }
    } catch (error) {
        console.error('Error handling YouTube action:', error);
        if (loadingIndicator.parentElement) {
            document.body.removeChild(loadingIndicator);
        }
        // Fallback en cas d'erreur
        setTimeout(() => window.open(url, '_blank'), 300);
    }
}

// Extraire l'ID vid√©o YouTube de diff√©rents formats d'URL
function extractYouTubeVideoId(url) {
    // Diff√©rents formats d'URL YouTube
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/watch\?.*v=([^&\n?#]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
    }
    
    return null;
}

// DEPRECATED: Old action popup system - now using unified modal
// Keeping for backward compatibility during transition
function hideMoreActions(element) {
    console.warn('hideMoreActions is deprecated - unified modal handles closing automatically');
}

/**
 * PROJECT HERO BLUR EFFECT
 * 
 * G√®re l'effet de blur progressif du background hero quand on scroll
 * vers la section de contenu texte
 */
document.addEventListener('DOMContentLoaded', function() {
    const projectHero = document.querySelector('.project-hero');
    const transitionElement = document.querySelector('.hero-to-content-transition');
    
    if (!projectHero || !transitionElement) return;
    
    // R√©cup√®re l'image de fond du hero et l'applique au body
    const heroStyle = window.getComputedStyle(projectHero);
    const bgImage = heroStyle.backgroundImage;
    
    if (bgImage && bgImage !== 'none') {
        document.body.style.setProperty('--hero-bg-image', bgImage);
    }
    
    function updateBlurEffect() {
        const scrollY = window.scrollY;
        const heroHeight = projectHero.offsetHeight;
        const windowHeight = window.innerHeight;
        
        // Calcule quand commencer l'effet (quand on commence √† voir la transition)
        const transitionStart = heroHeight - windowHeight * 0.3;
        const transitionEnd = heroHeight + 300; // Un peu apr√®s le d√©but de la transition
        
        // Calcule le pourcentage de progression
        let blurProgress = 0;
        if (scrollY >= transitionStart && scrollY <= transitionEnd) {
            blurProgress = (scrollY - transitionStart) / (transitionEnd - transitionStart);
            blurProgress = Math.max(0, Math.min(1, blurProgress)); // Clamp entre 0 et 1
        } else if (scrollY > transitionEnd) {
            blurProgress = 1;
        }
        
        // Applique une courbe d'easing pour un effet plus naturel
        const easeOutCubic = 1 - Math.pow(1 - blurProgress, 3);
        
        // Calcule les valeurs finales
        const blurValue = easeOutCubic * 20; // Maximum 20px de blur
        const transitionBlur = easeOutCubic * 5; // Maximum 5px pour la transition
        
        // Applique les effets sur le body (background fixe)
        document.body.style.setProperty('--blur-intensity', `${blurValue}px`);
        
        // Applique sur la transition
        transitionElement.style.setProperty('--transition-blur', `${transitionBlur}px`);
    }
    
    // √âv√©nements de scroll optimis√©s avec throttling
    let ticking = false;
    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(() => {
                updateBlurEffect();
                ticking = false;
            });
            ticking = true;
        }
    }
    
    window.addEventListener('scroll', requestTick, { passive: true });
    window.addEventListener('resize', requestTick, { passive: true });
    
    // Initialisation
    updateBlurEffect();
});

// ========================================
// TESTIMONIALS ROTATOR FUNCTIONALITY
// ========================================

// Variables globales pour contr√¥ler tous les t√©moignages
window.testimonialsGlobalPause = false;
window.testimonialsControllers = [];

// Fonctions globales pour contr√¥ler tous les t√©moignages
window.pauseAllTestimonials = function() {
    window.testimonialsGlobalPause = true;
    window.testimonialsControllers.forEach(controller => {
        if (controller.pauseRotation) {
            controller.pauseRotation();
        }
    });
    
    // Pause education testimonials
    if (window.educationTestimonialsPausers) {
        window.educationTestimonialsPausers.forEach(pauser => {
            if (pauser.pause) {
                pauser.pause();
            }
        });
    }
};

window.resumeAllTestimonials = function() {
    window.testimonialsGlobalPause = false;
    window.testimonialsControllers.forEach(controller => {
        if (controller.resumeRotation) {
            controller.resumeRotation();
        }
    });
    
    // Resume education testimonials
    if (window.educationTestimonialsPausers) {
        window.educationTestimonialsPausers.forEach(pauser => {
            if (pauser.resume) {
                pauser.resume();
            }
        });
    }
};

// Gestion de la rotation des testimonials
function initTestimonialsRotator() {
    const previewContainers = document.querySelectorAll('.widget-testimonials-rotator');
    
    previewContainers.forEach(container => {
        const items = container.querySelectorAll('.widget-testimonial-data-item');
        const progressBar = container.parentElement.querySelector('.widget-testimonials-progress');
        const quoteElement = container.querySelector('.widget-testimonial-preview-quote');
        
        if (items.length <= 1) return;
        
        let currentIndex = 0;
        let intervalId;
        let progressAnimationId;
        let isPaused = false;
        let pausedProgress = 0;
        
        function showTestimonial(index) {
            // R√©cup√©rer l'item √† l'index donn√©
            if (items[index]) {
                const activeItem = items[index];
                const testimonialQuote = activeItem.getAttribute('data-testimonial-quote');
                
                // Mettre √† jour le contenu du t√©moignage
                if (quoteElement && testimonialQuote) {
                    quoteElement.textContent = `"${testimonialQuote}"`;
                }
                
                // Mettre √† jour le header avec l'avatar et nom du t√©moigneur actuel
                updateTestimonialHeader(container, activeItem);
            }
        }
        
        function updateTestimonialHeader(container, activeItem) {
            // Trouver le widget parent
            const widget = container.closest('.widget-testimonials-box');
            if (!widget) return;
            
            // Trouver les √©l√©ments du header √† mettre √† jour
            const headerTitleElement = widget.querySelector('.project-widget-title-testimonial');
            if (!headerTitleElement) return;
            
            // R√©cup√©rer les informations du testimonial actif depuis les data attributes
            const personId = activeItem.getAttribute('data-person-id');
            const personName = activeItem.getAttribute('data-person-name');
            const personAvatar = activeItem.getAttribute('data-person-avatar');
            const personTitle = activeItem.getAttribute('data-person-title');
            
            // Si pas de nom de personne, utiliser un nom par d√©faut
            const displayName = personName || 'T√©moignage anonyme';
            
            // Mettre √† jour l'avatar dans le header
            const headerAvatar = headerTitleElement.querySelector('.project-widget-title-avatar');
            if (headerAvatar) {
                if (personAvatar) {
                    headerAvatar.classList.remove('placeholder');
                    headerAvatar.innerHTML = `<img src="${personAvatar}" alt="${displayName}">`;
                } else {
                    headerAvatar.classList.add('placeholder');
                    headerAvatar.innerHTML = `<span>${displayName.charAt(0).toUpperCase()}</span>`;
                }
            }
            
            // Mettre √† jour le nom dans le header
            const headerTitle = headerTitleElement.querySelector('.project-widget-title');
            if (headerTitle) {
                headerTitle.textContent = displayName;
            }
            
            // Mettre √† jour les attributs clickable-person si n√©cessaire
            if (personId) {
                // Supprimer d'abord les anciens attributs pour forcer la mise √† jour
                headerTitleElement.removeAttribute('data-person-id');
                headerTitleElement.removeAttribute('title');
                headerTitleElement.classList.remove('clickable-person');
                
                // Puis ajouter les nouveaux
                setTimeout(() => {
                    headerTitleElement.setAttribute('data-person-id', personId);
                    headerTitleElement.setAttribute('title', personTitle || `Voir le profil de ${displayName}`);
                    headerTitleElement.classList.add('clickable-person');
                    
                    // Supprimer l'ancien event listener s'il existe
                    if (headerTitleElement._testimonialClickHandler) {
                        headerTitleElement.removeEventListener('click', headerTitleElement._testimonialClickHandler);
                    }
                    
                    // Ajouter un nouvel event listener sp√©cifique
                    headerTitleElement._testimonialClickHandler = function(e) {
                        if (this.classList.contains('clickable-person')) {
                            e.stopPropagation();
                            const currentPersonId = this.getAttribute('data-person-id');
                            if (currentPersonId && typeof window.openPersonModal === 'function') {
                                window.openPersonModal(currentPersonId);
                            }
                        }
                    };
                    
                    headerTitleElement.addEventListener('click', headerTitleElement._testimonialClickHandler);
                }, 10);
            } else {
                headerTitleElement.removeAttribute('data-person-id');
                headerTitleElement.removeAttribute('title');
                headerTitleElement.classList.remove('clickable-person');
        
            }
        }
        
        function startProgressCycle() {
            if (!progressBar) return;
            
            // Supprimer l'animation CSS pour utiliser JS
            progressBar.style.animation = 'none';
            
            let progress = isPaused ? pausedProgress : 0;
            const duration = 6000; // 6 secondes
            const interval = 16; // Mise √† jour toutes les 16ms (60fps)
            const increment = (100 / duration) * interval;
            
            // Si on reprend depuis une pause, ne pas r√©initialiser la barre
            if (!isPaused) {
                progressBar.style.setProperty('--progress-width', '0%');
            }
            
            progressAnimationId = setInterval(() => {
                // Ne progresser que si pas en pause (locale OU globale)
                if (!isPaused && !window.testimonialsGlobalPause) {
                    progress += increment;
                    pausedProgress = progress;
                    
                    // Mettre √† jour la largeur via CSS custom property
                    progressBar.style.setProperty('--progress-width', Math.min(progress, 100) + '%');
                    
                    // Quand on atteint 100%, passer au suivant
                    if (progress >= 100) {
                        clearInterval(progressAnimationId);
                        
                        // Changer de testimonial
                        currentIndex = (currentIndex + 1) % items.length;
                        showTestimonial(currentIndex);
                        
                        // Red√©marrer le cycle apr√®s un petit d√©lai
                        setTimeout(() => {
                            if (progressAnimationId !== null) { // V√©rifier qu'on n'a pas √©t√© arr√™t√© entre temps
                                pausedProgress = 0;
                                isPaused = false;
                                startProgressCycle();
                            }
                        }, 100);
                    }
                }
            }, interval);
        }
        
        function showNextTestimonial() {
            // Fonction helper pour changement manuel
            currentIndex = (currentIndex + 1) % items.length;
            showTestimonial(currentIndex);
        }
        
        function startRotation() {
            // Arr√™ter toute rotation existante pour √©viter les conflits
            stopRotation();
            
            // S'assurer que le premier testimonial est affich√©
            showTestimonial(0);
            currentIndex = 0;
            
            // D√©marrer le cycle de progression unifi√©
            startProgressCycle();
        }
        
        function pauseRotation() {
            isPaused = true;
        }
        
        function resumeRotation() {
            isPaused = false;
        }
        
        function stopRotation() {
            // Arr√™ter l'animation de progression
            if (progressAnimationId) {
                clearInterval(progressAnimationId);
                progressAnimationId = null;
            }
            
            // R√©initialiser l'√©tat
            isPaused = false;
            pausedProgress = 0;
            
            // R√©initialiser la barre de progression
            if (progressBar) {
                progressBar.style.setProperty('--progress-width', '0%');
            }
        }
        
        // V√©rifier si le conteneur est visible
        function checkVisibility() {
            const infoBox = container.closest('.project-widget');
            const isTestimonialsBox = infoBox && infoBox.classList.contains('widget-testimonials-box');
            
            // Pour la testimonials-box, d√©marrer la rotation seulement si ferm√©e
            if (isTestimonialsBox) {
                const isExpanded = infoBox.classList.contains('expanded');
                if (!isExpanded) {
                    startRotation();
                } else {
                    stopRotation();
                }
                return;
            }
            
            // Pour les autres boxes, v√©rifier l'√©tat expanded
            const isExpanded = infoBox && infoBox.classList.contains('expanded');
            
            if (!isExpanded && container.offsetParent !== null) {
                startRotation();
            } else {
                stopRotation();
            }
        }
        
        // Observer les changements de classe expanded
    const infoBox = container.closest('.project-widget');
        if (infoBox) {
            const observer = new MutationObserver(() => {
                setTimeout(checkVisibility, 100); // Petit d√©lai pour laisser le CSS s'appliquer
            });
            
            observer.observe(infoBox, {
                attributes: true,
                attributeFilter: ['class']
            });
            
            // Ajouter les √©v√©nements de survol pour faire pause/reprendre
            infoBox.addEventListener('mouseenter', () => {
                if (progressAnimationId && !infoBox.classList.contains('expanded')) {
                    pauseRotation();
                }
            });
            
            infoBox.addEventListener('mouseleave', () => {
                if (progressAnimationId && !infoBox.classList.contains('expanded')) {
                    resumeRotation();
                }
            });
        }
        
        // Cr√©er un controller pour ce widget et l'enregistrer globalement
        const controller = {
            pauseRotation: pauseRotation,
            resumeRotation: resumeRotation,
            stopRotation: stopRotation,
            startRotation: startRotation,
            container: container
        };
        
        // Enregistrer ce controller dans la liste globale
        window.testimonialsControllers.push(controller);
        
        // Les gestionnaires d'√©v√©nements pour les clics sur les personnes sont maintenant
        // g√©r√©s dynamiquement dans updateTestimonialHeader()
        
        // D√©marrer imm√©diatement si visible
        setTimeout(checkVisibility, 500); // D√©lai initial pour s'assurer que le DOM est pr√™t
    });
}
// ========================================
// PROJECT WIDGET TOGGLE FUNCTIONALITY
// ========================================
// Initialize event handlers for project widgets
function initializeProjectWidgetHandlers() {
    // Find all project widget headers and add click handlers
    const widgetHeaders = document.querySelectorAll('.project-widget-header');
    
    widgetHeaders.forEach(header => {
        // Avoid double binding
        if (header.getAttribute('data-handler-bound') === 'true') return;
        header.setAttribute('data-handler-bound', 'true');
        
        // Add click handler
        header.addEventListener('click', function(e) {
            e.preventDefault();
            toggleInfoBox(this);
        });
        
        // Add keyboard handler for accessibility
        header.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                toggleInfoBox(this);
            }
        });
        
        // Make it focusable for keyboard navigation
        if (!header.hasAttribute('tabindex')) {
            header.setAttribute('tabindex', '0');
        }
        
        // Add visual cursor indication
        header.style.cursor = 'pointer';
    });
}

// Toggle ouvert/ferm√© pour les project-widgets
function toggleInfoBox(headerElem) {
    const box = headerElem.closest('.project-widget');
    if (!box) return;

    // Nouvelle logique : ouverture en modal plein √©cran via UnifiedModal
    if (typeof window.UnifiedModal !== 'undefined' && window.UnifiedModal.openProjectWidget) {
        window.UnifiedModal.openProjectWidget(box);
    } else {
        // Fallback: ancien comportement expand/collapse si UnifiedModal n'est pas charg√©
        box.classList.toggle('expanded');
    }
}

// ========================================
// YOUTUBE MODAL FUNCTIONALITY
// ========================================

// Ouvrir le modal YouTube
function openYouTubeModal(videoId, title) {
    const modal = document.getElementById('youtubeModal');
    const iframe = document.getElementById('youtubeIframe');
    const modalContent = modal.querySelector('.youtube-modal-content');
    
    if (modal && iframe && modalContent) {
        // Afficher l'indicateur de chargement
        modalContent.classList.add('loading');
        
        // D√©finir la source de l'iframe
        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0&modestbranding=1`;
        
        ModalUtils.pauseTestimonials();
        
        // Afficher le modal
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Masquer l'indicateur de chargement apr√®s un d√©lai
        setTimeout(() => {
            modalContent.classList.remove('loading');
        }, 1000);
        
        // √âcouter l'√©v√©nement de chargement de l'iframe
        iframe.onload = function() {
            modalContent.classList.remove('loading');
        };
    }
}

// Fermer le modal YouTube
function closeYouTubeModal() {
    const modal = document.getElementById('youtubeModal');
    const iframe = document.getElementById('youtubeIframe');
    const modalContent = modal.querySelector('.youtube-modal-content');
    
    if (modal && iframe && modalContent) {
        ModalUtils.resumeTestimonials();
        
        modal.classList.remove('active');
        
        // D√©lai pour laisser l'animation se terminer avant de supprimer la source
        setTimeout(() => {
            iframe.src = '';
            modalContent.classList.remove('loading');
        }, 300);
        
        // V√©rifier s'il y a d'autres modals ouvertes avant de remettre le body en scrollable
        try {
            const modalIds = ['unifiedModal', 'skillModal', 'personModal'];
            const anyModalOpen = modalIds.some(id => {
                const el = document.getElementById(id);
                if (!el) return false;
                const display = (el.style && el.style.display) ? el.style.display : window.getComputedStyle(el).display;
                return display && display !== 'none';
            });
            
            // Seulement remettre le body en scrollable s'il n'y a plus de modals ouvertes
            if (!anyModalOpen) {
                document.body.style.overflow = '';
            }
        } catch(e) {
            // En cas d'erreur, remettre en scrollable (comportement par d√©faut)
            document.body.style.overflow = '';
        }
    }
}

// Basculer l'affichage de la vid√©o YouTube int√©gr√©e
function toggleYouTubeEmbed(element, videoId, title) {
    const embedContainer = element.querySelector('.project-widget-youtube-single-embed');
    const thumbnail = element.querySelector('.project-widget-youtube-single-thumbnail');
    const iframe = embedContainer.querySelector('iframe');
    
    if (embedContainer.style.display === 'none') {
        // Afficher la vid√©o int√©gr√©e
        iframe.src = `https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1&rel=0&modestbranding=1`;
        embedContainer.style.display = 'block';
        thumbnail.style.display = 'none';
        
        ModalUtils.pauseTestimonials();
    } else {
        // Masquer la vid√©o int√©gr√©e
        iframe.src = '';
        embedContainer.style.display = 'none';
        thumbnail.style.display = 'block';
        
        ModalUtils.resumeTestimonials();
    }
}

// Close modal on Escape key
KeyboardManager.onEscape(() => {
    const modal = document.getElementById('youtubeModal');
    if (modal && modal.classList.contains('active')) {
        closeYouTubeModal();
        return true;
    }
    return false;
}, { priority: 80 });

// ========================================
// INITIALIZATION
// ========================================

// Initialiser toutes les fonctionnalit√©s au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser le rotateur de testimonials
    initTestimonialsRotator();
    
    // Pr√©venir la propagation des clics sur le contenu du modal
    const modalContent = document.querySelector('.youtube-modal-content');
    if (modalContent) {
        modalContent.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }

    // Initialiser le filtrage des comp√©tences
    initSkillsFiltering();
});

// Skills filtering functionality
function initSkillsFiltering() {
    const skillCategoryBtns = document.querySelectorAll('.skill-category-btn');
    const skillCategories = document.querySelectorAll('.skills-category');
    const skillsDescription = document.getElementById('skills-section-description');
    
    if (!skillCategoryBtns.length || !skillCategories.length) return;
    
    const skillDescriptions = {
        all: "Explorez toutes mes comp√©tences techniques organis√©es par cat√©gories. Cliquez sur une cat√©gorie pour filtrer les comp√©tences.",
        "programming-languages": "Langages de programmation que je ma√Ætrise, du niveau d√©butant √† expert selon mon exp√©rience pratique.",
        frameworks: "Frameworks et biblioth√®ques que j'utilise pour d√©velopper des applications robustes et performantes.",
        engines: "Moteurs de jeu et environnements de d√©veloppement pour la cr√©ation d'exp√©riences interactives.",
        environments: "Environnements de d√©veloppement int√©gr√©s (IDE) et √©diteurs de code que j'utilise au quotidien.",
        tools: "Outils de d√©veloppement, gestion de versions, cloud, design et autres utilitaires professionnels.",
        specialties: "Domaines de sp√©cialisation et expertises techniques sp√©cifiques √† mon profil.",
        "soft-skills": "Comp√©tences comportementales et relationnelles essentielles dans le travail en √©quipe."
    };
    
    skillCategoryBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active button
            skillCategoryBtns.forEach(button => button.classList.remove('active'));
            btn.classList.add('active');
            
            // Update description
            if (skillsDescription && skillDescriptions[category]) {
                skillsDescription.textContent = skillDescriptions[category];
            }
            
            // Show/hide skill categories
            skillCategories.forEach(skillCategory => {
                if (category === 'all') {
                    skillCategory.style.display = 'block';
                } else if (skillCategory.getAttribute('data-category') === category) {
                    skillCategory.style.display = 'block';
                } else {
                    skillCategory.style.display = 'none';
                }
            });
        });
    });
    
    // Initialize with "all" category active
    const allButton = document.querySelector('.skill-category-btn[data-category="all"]');
    if (allButton && !document.querySelector('.skill-category-btn.active')) {
        allButton.click();
    }
}

/**
 * Global handler for avatar images that fail to load
 * Converts failed avatar images to placeholder with initial
 */
document.addEventListener('DOMContentLoaded', function() {
    // Function to handle avatar image errors
    function handleAvatarError(img) {
        const parent = img.parentElement;
        if (!parent) return;
        
        // Try to extract the person name from various sources
        let personName = '';
        
        // Method 1: Get from alt attribute (clean version)
        const altText = img.alt || '';
        if (altText && altText !== 'Avatar') {
            // Remove "Avatar de " or similar prefixes
            personName = altText.replace(/^Avatar\s+(de\s+)?/i, '').trim();
        }
        
        // Method 2: Get from nearby elements (for contrib cards, testimonial cards, etc.)
        if (!personName) {
            const card = parent.closest('.contrib-card, .testimonial-item, .testimonial-author');
            if (card) {
                const nameElement = card.querySelector('.contrib-name, .author-name, .testimonial-name');
                if (nameElement) {
                    personName = nameElement.textContent.trim();
                }
            }
        }
        
        // Method 3: Get from data attributes
        if (!personName) {
            const dataElement = parent.closest('[data-person-name]');
            if (dataElement) {
                personName = dataElement.getAttribute('data-person-name');
            }
        }
        
        // Method 4: Get from title attribute
        if (!personName && parent.title) {
            personName = parent.title.replace(/^Voir le profil de\s+/i, '').trim();
        }
        
        // Fallback to first letter of alt or '?'
        const initial = personName ? personName.charAt(0).toUpperCase() : (altText ? altText.charAt(0).toUpperCase() : '?');
        
        // Hide the image
        img.style.display = 'none';
        
        // Add placeholder class to parent
        parent.classList.add('placeholder');
        
        // Create or update the span with initial
        let span = parent.querySelector('span');
        if (!span) {
            span = document.createElement('span');
            parent.appendChild(span);
        }
        span.textContent = initial;
    }
    
    // Add error handlers to all avatar images
    const avatarSelectors = [
        '.contributor-avatar-mini img',
        '.contrib-avatar img',
        '.author-avatar img',
        '.testimonial-avatar:not(.placeholder)',
        '.project-widget-title-avatar img',
        '.people-avatar img'
    ];
    
    avatarSelectors.forEach(selector => {
        const images = document.querySelectorAll(selector);
        images.forEach(img => {
            // Check if image is already loaded and failed
            if (img.complete && img.naturalHeight === 0) {
                handleAvatarError(img);
            }
            // Add error handler for future errors
            img.addEventListener('error', function() {
                handleAvatarError(this);
            });
        });
    });
    
    // Observer for dynamically added images
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // Element node
                    avatarSelectors.forEach(selector => {
                        // Check the node itself
                        if (node.matches && node.matches(selector)) {
                            const img = node.tagName === 'IMG' ? node : node.querySelector('img');
                            if (img) {
                                img.addEventListener('error', function() {
                                    handleAvatarError(this);
                                });
                            }
                        }
                        // Check descendants
                        const images = node.querySelectorAll ? node.querySelectorAll(selector) : [];
                        images.forEach(img => {
                            img.addEventListener('error', function() {
                                handleAvatarError(this);
                            });
                        });
                    });
                }
            });
        });
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
});
