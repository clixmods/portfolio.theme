console.log('This site was generated by Hugo.');

// Utility function to convert hex to RGB
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// Initialize tech badge colors
function initializeTechBadgeColors() {
    const techBadges = document.querySelectorAll('.tech-badge[style*="--tech-color"]');
    techBadges.forEach(badge => {
        const style = badge.getAttribute('style');
        const colorMatch = style.match(/--tech-color:\s*([^;]+)/);
        if (colorMatch) {
            const hexColor = colorMatch[1].trim();
            const rgb = hexToRgb(hexColor);
            if (rgb) {
                badge.style.setProperty('--tech-color', hexColor);
                badge.style.setProperty('--tech-color-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            }
        }
    });
}

// Navigation Menu Functionality
document.addEventListener('DOMContentLoaded', function() {
    const navItems = document.querySelectorAll('.nav-item');
    const sections = document.querySelectorAll('section[id]');
    
    // Smooth scrolling for navigation links
    navItems.forEach(navItem => {
        navItem.addEventListener('click', function(e) {
            e.preventDefault();
            
            const targetId = this.getAttribute('href').substring(1);
            const targetSection = document.getElementById(targetId);
            
            if (targetSection) {
                // Update active nav item
                navItems.forEach(item => item.classList.remove('active'));
                this.classList.add('active');
                
                // Smooth scroll to section
                targetSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
    
    // Update active nav item on scroll
    function updateActiveNavOnScroll() {
        let current = '';
        const scrollPosition = window.pageYOffset + 200; // Adjusted offset for better detection
        
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            
            if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                current = section.getAttribute('id');
            }
        });
        
        // If we're at the top of the page, highlight the first section
        if (window.pageYOffset < 100) {
            current = 'profil';
        }
        
        // Update nav items
        navItems.forEach(navItem => {
            navItem.classList.remove('active');
            const href = navItem.getAttribute('href');
            if (href === `#${current}`) {
                navItem.classList.add('active');
            }
        });
    }
    
    // Scroll progress bar function
    function updateScrollProgress() {
        const scrollTop = window.pageYOffset;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = (scrollTop / docHeight) * 100;
        
        const progressBar = document.querySelector('.scroll-progress-bar');
        if (progressBar) {
            progressBar.style.width = scrollPercent + '%';
        }
    }
    
    // Listen for scroll events with throttling for performance
    let scrollTimeout;
    window.addEventListener('scroll', function() {
        if (scrollTimeout) {
            clearTimeout(scrollTimeout);
        }
        scrollTimeout = setTimeout(() => {
            updateActiveNavOnScroll();
            updateScrollProgress();
        }, 10);
    });
    
    // Initial calls
    updateActiveNavOnScroll();
    updateScrollProgress();
});

// Expose functions globally for inline onclick handlers
window.openYouTubeModal = openYouTubeModal;
window.closeYouTubeModal = closeYouTubeModal;
window.toggleInfoBox = toggleInfoBox;

// Projects Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Initialize tech badge colors
    initializeTechBadgeColors();
    
    // Tab switching functionality
    const tabBtns = document.querySelectorAll('.tab-btn');
    const projectCards = document.querySelectorAll('.ps5-project-tile');
    const sectionDescription = document.getElementById('section-description');
    
    const descriptions = {
        games: "Projets de développement de jeux vidéo, du prototypage à la production commerciale.",
        "apps-web": "Applications web modernes et solutions full-stack utilisant les dernières technologies.",
        "mods-tools": "Outils de développement, mods et utilitaires pour améliorer les workflows créatifs."
    };
    
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            tabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Update description
            if (sectionDescription) {
                sectionDescription.textContent = descriptions[category];
            }
            
            // Show/hide cards based on category
            projectCards.forEach(card => {
                if (card.getAttribute('data-category') === category) {
                    card.style.display = 'flex';
                    card.classList.remove('hiding');
                    card.classList.add('showing');
                } else {
                    card.classList.remove('showing');
                    card.classList.add('hiding');
                    setTimeout(() => {
                        if (card.classList.contains('hiding')) {
                            card.style.display = 'none';
                        }
                    }, 400);
                }
            });
            
            // Animate visible tiles
            setTimeout(() => {
                const visibleTiles = Array.from(projectCards).filter(tile => 
                    tile.getAttribute('data-category') === category && 
                    getComputedStyle(tile).display !== 'none'
                );
                
                visibleTiles.forEach((tile, index) => {
                    tile.classList.add('tile-ready');
                    setTimeout(() => {
                        tile.classList.add('tile-visible');
                    }, index * 90);
                });
            }, 100);
        });
    });
    
    // Initialize card animations
    projectCards.forEach(card => {
        card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    });
    
    // Initialize projects display - show only the active category (games by default)
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab) {
        const activeCategory = activeTab.getAttribute('data-category');
        
        // Update description for active category
        if (sectionDescription && descriptions[activeCategory]) {
            sectionDescription.textContent = descriptions[activeCategory];
        }
        
        // Show/hide cards based on active category
        projectCards.forEach(card => {
            if (card.getAttribute('data-category') === activeCategory) {
                card.style.display = 'flex';
                card.classList.remove('hiding');
                card.classList.add('showing');
            } else {
                card.style.display = 'none';
            }
        });
    }
    
    // Initialize tile visibility animation (similar to ps5-projects.js)
    projectCards.forEach(tile => tile.classList.add('tile-ready'));
    
    // Staggered fade-in for visible tiles
    const visibleTiles = Array.from(projectCards).filter(tile => 
        getComputedStyle(tile).display !== 'none'
    );
    
    visibleTiles.forEach((tile, index) => {
        setTimeout(() => {
            tile.classList.add('tile-visible');
        }, index * 90);
    });
});

// Education Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    const eduTabBtns = document.querySelectorAll('.edu-tab-btn');
    const educationTimeline = document.getElementById('education-timeline');
    const certificationsTimeline = document.getElementById('certifications-timeline');
    
    eduTabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            eduTabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Show/hide timelines with animation
            if (category === 'education') {
                // Hide certifications
                if (certificationsTimeline) {
                    certificationsTimeline.style.opacity = '0';
                    certificationsTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        certificationsTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show education
                if (educationTimeline) {
                    setTimeout(() => {
                        educationTimeline.style.display = 'block';
                        setTimeout(() => {
                            educationTimeline.style.opacity = '1';
                            educationTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            } else if (category === 'certifications') {
                // Hide education
                if (educationTimeline) {
                    educationTimeline.style.opacity = '0';
                    educationTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        educationTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show certifications
                if (certificationsTimeline) {
                    setTimeout(() => {
                        certificationsTimeline.style.display = 'block';
                        setTimeout(() => {
                            certificationsTimeline.style.opacity = '1';
                            certificationsTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            }
        });
    });
    
    // Initialize timeline animations
    const timelines = [educationTimeline, certificationsTimeline];
    timelines.forEach(timeline => {
        if (timeline) {
            timeline.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            timeline.style.opacity = timeline.id === 'education-timeline' ? '1' : '0';
            timeline.style.transform = 'translateY(0)';
        }
    });
});

// Experience Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    const expTabBtns = document.querySelectorAll('.exp-tab-btn');
    const experiencesTimeline = document.getElementById('experiences-timeline');
    const internshipsTimeline = document.getElementById('internships-timeline');
    
    expTabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            expTabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Show/hide timelines with animation
            if (category === 'experiences') {
                // Hide internships
                if (internshipsTimeline) {
                    internshipsTimeline.style.opacity = '0';
                    internshipsTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        internshipsTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show experiences
                if (experiencesTimeline) {
                    setTimeout(() => {
                        experiencesTimeline.style.display = 'block';
                        setTimeout(() => {
                            experiencesTimeline.style.opacity = '1';
                            experiencesTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            } else if (category === 'internships') {
                // Hide experiences
                if (experiencesTimeline) {
                    experiencesTimeline.style.opacity = '0';
                    experiencesTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        experiencesTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show internships
                if (internshipsTimeline) {
                    setTimeout(() => {
                        internshipsTimeline.style.display = 'block';
                        setTimeout(() => {
                            internshipsTimeline.style.opacity = '1';
                            internshipsTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            }
        });
    });
    
    // Initialize timeline animations
    const expTimelines = [experiencesTimeline, internshipsTimeline];
    expTimelines.forEach(timeline => {
        if (timeline) {
            timeline.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            timeline.style.opacity = timeline.id === 'experiences-timeline' ? '1' : '0';
            timeline.style.transform = 'translateY(0)';
        }
    });
});

// Testimonials Slider
document.addEventListener('DOMContentLoaded', function() {
    const slider = document.querySelector('.testimonials-slider');
    if (!slider) return;

    const track = slider.querySelector('.testimonials-track');
    const cards = slider.querySelectorAll('.testimonial-card');
    const prevBtn = slider.querySelector('.slider-btn.prev');
    const nextBtn = slider.querySelector('.slider-btn.next');
    const indicators = slider.querySelectorAll('.indicator');
    
    let currentIndex = 0;
    const totalCards = cards.length;

    // Function to update slider position
    function updateSlider() {
        const translateX = -currentIndex * 100;
        track.style.transform = `translateX(${translateX}%)`;
        
        // Update indicators
        indicators.forEach((indicator, index) => {
            indicator.classList.toggle('active', index === currentIndex);
        });
        
        // Update button states
        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === totalCards - 1;
    }

    // Next button
    nextBtn.addEventListener('click', () => {
        if (currentIndex < totalCards - 1) {
            currentIndex++;
            updateSlider();
        }
    });

    // Previous button
    prevBtn.addEventListener('click', () => {
        if (currentIndex > 0) {
            currentIndex--;
            updateSlider();
        }
    });

    // Indicator clicks
    indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => {
            currentIndex = index;
            updateSlider();
        });
    });

    // Auto-play slider
    setInterval(() => {
        if (currentIndex < totalCards - 1) {
            currentIndex++;
        } else {
            currentIndex = 0;
        }
        updateSlider();
    }, 5000); // Change slide every 5 seconds

    // Initialize slider
    updateSlider();

    // Touch/swipe support for mobile
    let startX = null;
    let startY = null;

    slider.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });

    slider.addEventListener('touchmove', (e) => {
        if (!startX || !startY) return;
        
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        
        const diffX = startX - currentX;
        const diffY = startY - currentY;
        
        // Only handle horizontal swipes
        if (Math.abs(diffX) > Math.abs(diffY)) {
            e.preventDefault();
        }
    });

    slider.addEventListener('touchend', (e) => {
        if (!startX || !startY) return;
        
        const endX = e.changedTouches[0].clientX;
        const diffX = startX - endX;
        
        // Minimum swipe distance
        if (Math.abs(diffX) > 50) {
            if (diffX > 0 && currentIndex < totalCards - 1) {
                // Swipe left - next slide
                currentIndex++;
                updateSlider();
            } else if (diffX < 0 && currentIndex > 0) {
                // Swipe right - previous slide
                currentIndex--;
                updateSlider();
            }
        }
        
        startX = null;
        startY = null;
    });
});

// Contact Form Functionality
document.addEventListener('DOMContentLoaded', function() {
    const contactForm = document.getElementById('contactForm');
    
    if (contactForm) {
        contactForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Get form data
            const formData = new FormData(contactForm);
            const name = formData.get('name');
            const email = formData.get('email');
            const subject = formData.get('subject');
            const message = formData.get('message');
            
            // Basic validation
            if (!name || !email || !message) {
                showNotification('Veuillez remplir tous les champs requis.', 'error');
                return;
            }
            
            // Email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                showNotification('Veuillez entrer une adresse email valide.', 'error');
                return;
            }
            
            // Show loading state
            const submitBtn = contactForm.querySelector('.submit-btn');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '<span>Envoi en cours...</span><div class="btn-icon">⏳</div>';
            submitBtn.disabled = true;
            
            // Simulate form submission (replace with actual form handling)
            setTimeout(() => {
                // Create mailto link as fallback
                const mailtoLink = `mailto:clement.g.developer@gmail.com?subject=${encodeURIComponent(subject || 'Contact depuis le portfolio')}&body=${encodeURIComponent(`Nom: ${name}\nEmail: ${email}\n\nMessage:\n${message}`)}`;
                
                // Open default email client
                window.location.href = mailtoLink;
                
                // Reset form
                contactForm.reset();
                
                // Reset button
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;
                
                // Show success message
                showNotification('Votre message a été préparé dans votre client email !', 'success');
            }, 1000);
        });
    }
    
    // Form field animations
    const formInputs = document.querySelectorAll('.contact-form input, .contact-form select, .contact-form textarea');
    
    formInputs.forEach(input => {
        input.addEventListener('focus', function() {
            this.parentElement.classList.add('focused');
        });
        
        input.addEventListener('blur', function() {
            if (!this.value) {
                this.parentElement.classList.remove('focused');
            }
        });
        
        // Check if field has value on page load
        if (input.value) {
            input.parentElement.classList.add('focused');
        }
    });
});

// Notification system - Utilise le système du right-dock si disponible
function showNotification(message, type = 'info') {
    // Vérifier si le système de notifications du right-dock est disponible
    if (window.rightDockManager && window.rightDockManager.showNotification) {
        window.rightDockManager.showNotification(message, type);
        return;
    }
    
    // Fallback : système de notifications simple
    // Remove existing notifications
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => notification.remove());
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
        <div class="notification-content">
            <span class="notification-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
            <span class="notification-message">${message}</span>
            <button class="notification-close" onclick="this.parentElement.parentElement.remove()">✕</button>
        </div>
    `;
    
    // Add styles for notification
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? 'rgba(34, 197, 94, 0.9)' : type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(59, 130, 246, 0.9)'};
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 1rem;
        color: white;
        z-index: 10000;
        animation: slideInRight 0.3s ease;
        max-width: 400px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    `;
    
    // Add notification styles to document if not already present
    if (!document.querySelector('#notification-styles')) {
        const style = document.createElement('style');
        style.id = 'notification-styles';
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            .notification-content {
                display: flex;
                align-items: center;
                gap: 0.75rem;
            }
            
            .notification-close {
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 1.2rem;
                padding: 0;
                margin-left: auto;
                opacity: 0.7;
                transition: opacity 0.2s ease;
            }
            
            .notification-close:hover {
                opacity: 1;
            }
            
            .notification-icon {
                font-size: 1.2rem;
            }
            
            .notification-message {
                flex: 1;
                font-size: 0.95rem;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add to page
    document.body.appendChild(notification);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.style.animation = 'slideInRight 0.3s ease reverse';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}

// Project Actions - Show More functionality
function showMoreActions(button) {
    console.log('showMoreActions called', button);
    
    // Recherche directe de la popup dans tout le document
    const popup = document.querySelector('.actions-popup');
    
    console.log('popup found:', popup);
    
    if (popup) {
        popup.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        console.log('popup shown');
    } else {
        console.error('Popup not found!');
        // Afficher toutes les popups disponibles pour débug
        console.log('All elements with actions-popup class:', document.querySelectorAll('.actions-popup'));
        console.log('Button parent:', button.parentElement);
        console.log('Button parent children:', button.parentElement.children);
    }
}

function hideMoreActions(element) {
    // Remonter jusqu'à trouver la popup
    let popup = element.closest('.actions-popup');
    if (!popup) {
        popup = element.parentElement.querySelector('.actions-popup');
    }
    
    if (popup) {
        popup.style.display = 'none';
        document.body.style.overflow = '';
    }
}

// Fermer le popup avec Escape
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const openPopup = document.querySelector('.actions-popup[style*="flex"]');
        if (openPopup) {
            hideMoreActions(openPopup);
        }
    }
});

/**
 * PROJECT HERO BLUR EFFECT
 * 
 * Gère l'effet de blur progressif du background hero quand on scroll
 * vers la section de contenu texte
 */
document.addEventListener('DOMContentLoaded', function() {
    const projectHero = document.querySelector('.project-hero');
    const transitionElement = document.querySelector('.hero-to-content-transition');
    
    if (!projectHero || !transitionElement) return;
    
    // Récupère l'image de fond du hero et l'applique au body
    const heroStyle = window.getComputedStyle(projectHero);
    const bgImage = heroStyle.backgroundImage;
    
    if (bgImage && bgImage !== 'none') {
        document.body.style.setProperty('--hero-bg-image', bgImage);
    }
    
    function updateBlurEffect() {
        const scrollY = window.scrollY;
        const heroHeight = projectHero.offsetHeight;
        const windowHeight = window.innerHeight;
        
        // Calcule quand commencer l'effet (quand on commence à voir la transition)
        const transitionStart = heroHeight - windowHeight * 0.3;
        const transitionEnd = heroHeight + 300; // Un peu après le début de la transition
        
        // Calcule le pourcentage de progression
        let blurProgress = 0;
        if (scrollY >= transitionStart && scrollY <= transitionEnd) {
            blurProgress = (scrollY - transitionStart) / (transitionEnd - transitionStart);
            blurProgress = Math.max(0, Math.min(1, blurProgress)); // Clamp entre 0 et 1
        } else if (scrollY > transitionEnd) {
            blurProgress = 1;
        }
        
        // Applique une courbe d'easing pour un effet plus naturel
        const easeOutCubic = 1 - Math.pow(1 - blurProgress, 3);
        
        // Calcule les valeurs finales
        const blurValue = easeOutCubic * 20; // Maximum 20px de blur
        const transitionBlur = easeOutCubic * 5; // Maximum 5px pour la transition
        
        // Applique les effets sur le body (background fixe)
        document.body.style.setProperty('--blur-intensity', `${blurValue}px`);
        
        // Applique sur la transition
        transitionElement.style.setProperty('--transition-blur', `${transitionBlur}px`);
    }
    
    // Événements de scroll optimisés avec throttling
    let ticking = false;
    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(() => {
                updateBlurEffect();
                ticking = false;
            });
            ticking = true;
        }
    }
    
    window.addEventListener('scroll', requestTick, { passive: true });
    window.addEventListener('resize', requestTick, { passive: true });
    
    // Initialisation
    updateBlurEffect();
});

// ========================================
// TESTIMONIALS ROTATOR FUNCTIONALITY
// ========================================

// Gestion de la rotation des testimonials
function initTestimonialsRotator() {
    const previewContainers = document.querySelectorAll('.testimonials-rotator');
    
    previewContainers.forEach(container => {
        const items = container.querySelectorAll('.testimonial-preview-item');
        if (items.length <= 1) return;
        
        let currentIndex = 0;
        let intervalId;
        
        function showTestimonial(index) {
            // Masquer tous les testimonials
            items.forEach(item => item.classList.remove('active'));
            
            // Afficher le testimonial à l'index donné
            if (items[index]) {
                items[index].classList.add('active');
            }
        }
        
        function showNextTestimonial() {
            // Passer au suivant
            currentIndex = (currentIndex + 1) % items.length;
            showTestimonial(currentIndex);
        }
        
        function startRotation() {
            // Arrêter toute rotation existante pour éviter les conflits
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            
            // S'assurer que le premier testimonial est affiché
            showTestimonial(0);
            currentIndex = 0;
            
            // Démarrer la rotation automatique avec un délai plus long
            intervalId = setInterval(showNextTestimonial, 6000); // 6 secondes par testimonial
        }
        
        function stopRotation() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        }
        
        // Vérifier si le conteneur est visible
        function checkVisibility() {
            const infoBox = container.closest('.info-box');
            const isTestimonialsBox = infoBox && infoBox.classList.contains('testimonials-box');
            
            // Pour la testimonials-box, démarrer la rotation seulement si fermée
            if (isTestimonialsBox) {
                const isExpanded = infoBox.classList.contains('expanded');
                if (!isExpanded) {
                    startRotation();
                } else {
                    stopRotation();
                }
                return;
            }
            
            // Pour les autres boxes, vérifier l'état expanded
            const isExpanded = infoBox && infoBox.classList.contains('expanded');
            
            if (!isExpanded && container.offsetParent !== null) {
                startRotation();
            } else {
                stopRotation();
            }
        }
        
        // Observer les changements de classe expanded
        const infoBox = container.closest('.info-box');
        if (infoBox) {
            const observer = new MutationObserver(() => {
                setTimeout(checkVisibility, 100); // Petit délai pour laisser le CSS s'appliquer
            });
            
            observer.observe(infoBox, {
                attributes: true,
                attributeFilter: ['class']
            });
        }
        
        // Démarrer immédiatement si visible
        setTimeout(checkVisibility, 500); // Délai initial pour s'assurer que le DOM est prêt
    });
}
// ========================================
// INFO BOX TOGGLE FUNCTIONALITY
// ========================================
// Toggle ouvert/fermé pour les info-box
function toggleInfoBox(headerElem) {
    const box = headerElem.closest('.info-box');
    if (box) {
        box.classList.toggle('expanded');
    }
}

// ========================================
// YOUTUBE MODAL FUNCTIONALITY
// ========================================

// Ouvrir le modal YouTube
function openYouTubeModal(videoId, title) {
    const modal = document.getElementById('youtubeModal');
    const iframe = document.getElementById('youtubeIframe');
    const modalContent = modal.querySelector('.youtube-modal-content');
    
    if (modal && iframe && modalContent) {
        // Afficher l'indicateur de chargement
        modalContent.classList.add('loading');
        
        // Définir la source de l'iframe
        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0&modestbranding=1`;
        
        // Afficher le modal
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Masquer l'indicateur de chargement après un délai
        setTimeout(() => {
            modalContent.classList.remove('loading');
        }, 1000);
        
        // Écouter l'événement de chargement de l'iframe
        iframe.onload = function() {
            modalContent.classList.remove('loading');
        };
    }
}

// Fermer le modal YouTube
function closeYouTubeModal() {
    const modal = document.getElementById('youtubeModal');
    const iframe = document.getElementById('youtubeIframe');
    const modalContent = modal.querySelector('.youtube-modal-content');
    
    if (modal && iframe && modalContent) {
        modal.classList.remove('active');
        
        // Délai pour laisser l'animation se terminer avant de supprimer la source
        setTimeout(() => {
            iframe.src = '';
            modalContent.classList.remove('loading');
        }, 300);
        
        document.body.style.overflow = '';
    }
}

// Fermer le modal avec la touche Échap
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        closeYouTubeModal();
    }
});

// ========================================
// INITIALIZATION
// ========================================

// Initialiser toutes les fonctionnalités au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser le rotateur de testimonials
    initTestimonialsRotator();
    
    // Prévenir la propagation des clics sur le contenu du modal
    const modalContent = document.querySelector('.youtube-modal-content');
    if (modalContent) {
        modalContent.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }
});
