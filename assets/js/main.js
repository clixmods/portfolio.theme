console.log('This site was generated by Hugo.');

// Utility function to convert hex to RGB
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// Initialize tech badge colors
function initializeTechBadgeColors() {
    const techBadges = document.querySelectorAll('.tech-badge[style*="--tech-color"]');
    techBadges.forEach(badge => {
        const style = badge.getAttribute('style');
        const colorMatch = style.match(/--tech-color:\s*([^;]+)/);
        if (colorMatch) {
            const hexColor = colorMatch[1].trim();
            const rgb = hexToRgb(hexColor);
            if (rgb) {
                badge.style.setProperty('--tech-color', hexColor);
                badge.style.setProperty('--tech-color-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            }
        }
    });
}

// Navigation Menu Functionality
document.addEventListener('DOMContentLoaded', function() {
    const navItems = document.querySelectorAll('.nav-item');
    const sections = document.querySelectorAll('section[id]');
    
    // Smooth scrolling for navigation links
    navItems.forEach(navItem => {
        navItem.addEventListener('click', function(e) {
            e.preventDefault();
            
            const targetId = this.getAttribute('href').substring(1);
            const targetSection = document.getElementById(targetId);
            
            if (targetSection) {
                // Update active nav item
                navItems.forEach(item => item.classList.remove('active'));
                this.classList.add('active');
                
                // Smooth scroll to section
                targetSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
    
    // Update active nav item on scroll
    function updateActiveNavOnScroll() {
        let current = '';
        const scrollPosition = window.pageYOffset + 200; // Adjusted offset for better detection
        
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            
            if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                current = section.getAttribute('id');
            }
        });
        
        // If we're at the top of the page, highlight the first section
        if (window.pageYOffset < 100) {
            current = 'profil';
        }
        
        // Update nav items
        navItems.forEach(navItem => {
            navItem.classList.remove('active');
            const href = navItem.getAttribute('href');
            if (href === `#${current}`) {
                navItem.classList.add('active');
            }
        });
    }
    
    // Scroll progress bar function
    function updateScrollProgress() {
        const scrollTop = window.pageYOffset;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = (scrollTop / docHeight) * 100;
        
        const progressBar = document.querySelector('.scroll-progress-bar');
        if (progressBar) {
            progressBar.style.width = scrollPercent + '%';
        }
    }
    
    // Listen for scroll events with throttling for performance
    let scrollTimeout;
    window.addEventListener('scroll', function() {
        if (scrollTimeout) {
            clearTimeout(scrollTimeout);
        }
        scrollTimeout = setTimeout(() => {
            updateActiveNavOnScroll();
            updateScrollProgress();
        }, 10);
    });
    
    // Initial calls
    updateActiveNavOnScroll();
    updateScrollProgress();
});

// Fonction utilitaire pour afficher des notifications
function showNotification(message, type = 'info', duration = 5000) {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
        ${getNotificationIcon(type)} ${message}
        <button onclick="this.parentElement.remove()" style="margin-left: 10px; background: none; border: none; color: inherit; cursor: pointer; font-size: 16px;">‚úï</button>
    `;
    
    const baseStyles = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 16px;
        border-radius: 8px;
        z-index: 10002;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideInRight 0.3s ease;
        max-width: 300px;
        word-wrap: break-word;
    `;
    
    const typeStyles = {
        info: 'background: #007acc; color: white;',
        success: 'background: #28a745; color: white;',
        warning: 'background: #ffc107; color: #212529;',
        error: 'background: #dc3545; color: white;'
    };
    
    notification.style.cssText = baseStyles + typeStyles[type];
    
    document.body.appendChild(notification);
    
    // Auto-supprimer apr√®s la dur√©e sp√©cifi√©e
    setTimeout(() => {
        if (notification.parentElement) {
            notification.style.animation = 'slideOutRight 0.3s ease';
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 300);
        }
    }, duration);
}

function getNotificationIcon(type) {
    const icons = {
        info: '‚ÑπÔ∏è',
        success: '‚úÖ',
        warning: '‚ö†Ô∏è',
        error: '‚ùå'
    };
    return icons[type] || icons.info;
}

// Expose functions globally for inline onclick handlers
window.openYouTubeModal = openYouTubeModal;
window.closeYouTubeModal = closeYouTubeModal;
window.toggleInfoBox = toggleInfoBox;
window.showMoreActions = showMoreActions;
window.hideMoreActions = hideMoreActions;
window.handleYouTubeAction = handleYouTubeAction;
window.extractYouTubeVideoId = extractYouTubeVideoId;
window.showNotification = showNotification;

// Projects Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Initialize tech badge colors
    initializeTechBadgeColors();
    
    // Tab switching functionality
    const tabBtns = document.querySelectorAll('.tab-btn');
    const projectCards = document.querySelectorAll('.ps5-project-tile');
    const sectionDescription = document.getElementById('section-description');
    
    const descriptions = {
        games: "Projets de d√©veloppement de jeux vid√©o, du prototypage √† la production commerciale.",
        "apps-web": "Applications web modernes et solutions full-stack utilisant les derni√®res technologies.",
        "mods-tools": "Outils de d√©veloppement, mods et utilitaires pour am√©liorer les workflows cr√©atifs."
    };
    
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            tabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Update description
            if (sectionDescription) {
                sectionDescription.textContent = descriptions[category];
            }
            
            // Show/hide cards based on category
            projectCards.forEach(card => {
                if (card.getAttribute('data-category') === category) {
                    card.style.display = 'flex';
                    card.classList.remove('hiding');
                    card.classList.add('showing');
                } else {
                    card.classList.remove('showing');
                    card.classList.add('hiding');
                    setTimeout(() => {
                        if (card.classList.contains('hiding')) {
                            card.style.display = 'none';
                        }
                    }, 400);
                }
            });
            
            // Animate visible tiles
            setTimeout(() => {
                const visibleTiles = Array.from(projectCards).filter(tile => 
                    tile.getAttribute('data-category') === category && 
                    getComputedStyle(tile).display !== 'none'
                );
                
                visibleTiles.forEach((tile, index) => {
                    tile.classList.add('tile-ready');
                    setTimeout(() => {
                        tile.classList.add('tile-visible');
                    }, index * 90);
                });
            }, 100);
        });
    });
    
    // Initialize card animations
    projectCards.forEach(card => {
        card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    });
    
    // Initialize projects display - show only the active category (games by default)
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab) {
        const activeCategory = activeTab.getAttribute('data-category');
        
        // Update description for active category
        if (sectionDescription && descriptions[activeCategory]) {
            sectionDescription.textContent = descriptions[activeCategory];
        }
        
        // Show/hide cards based on active category
        projectCards.forEach(card => {
            if (card.getAttribute('data-category') === activeCategory) {
                card.style.display = 'flex';
                card.classList.remove('hiding');
                card.classList.add('showing');
            } else {
                card.style.display = 'none';
            }
        });
    }
    
    // Initialize tile visibility animation (similar to ps5-projects.js)
    projectCards.forEach(tile => tile.classList.add('tile-ready'));
    
    // Staggered fade-in for visible tiles
    const visibleTiles = Array.from(projectCards).filter(tile => 
        getComputedStyle(tile).display !== 'none'
    );
    
    visibleTiles.forEach((tile, index) => {
        setTimeout(() => {
            tile.classList.add('tile-visible');
        }, index * 90);
    });
});

// Education Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    const eduTabBtns = document.querySelectorAll('.edu-tab-btn');
    const educationTimeline = document.getElementById('education-timeline');
    const certificationsTimeline = document.getElementById('certifications-timeline');
    
    eduTabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            eduTabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Show/hide timelines with animation
            if (category === 'education') {
                // Hide certifications
                if (certificationsTimeline) {
                    certificationsTimeline.style.opacity = '0';
                    certificationsTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        certificationsTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show education
                if (educationTimeline) {
                    setTimeout(() => {
                        educationTimeline.style.display = 'block';
                        setTimeout(() => {
                            educationTimeline.style.opacity = '1';
                            educationTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            } else if (category === 'certifications') {
                // Hide education
                if (educationTimeline) {
                    educationTimeline.style.opacity = '0';
                    educationTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        educationTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show certifications
                if (certificationsTimeline) {
                    setTimeout(() => {
                        certificationsTimeline.style.display = 'block';
                        setTimeout(() => {
                            certificationsTimeline.style.opacity = '1';
                            certificationsTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            }
        });
    });
    
    // Initialize timeline animations
    const timelines = [educationTimeline, certificationsTimeline];
    timelines.forEach(timeline => {
        if (timeline) {
            timeline.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            timeline.style.opacity = timeline.id === 'education-timeline' ? '1' : '0';
            timeline.style.transform = 'translateY(0)';
        }
    });
});

// Experience Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    const expTabBtns = document.querySelectorAll('.exp-tab-btn');
    const experiencesTimeline = document.getElementById('experiences-timeline');
    const internshipsTimeline = document.getElementById('internships-timeline');
    
    expTabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            expTabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Show/hide timelines with animation
            if (category === 'experiences') {
                // Hide internships
                if (internshipsTimeline) {
                    internshipsTimeline.style.opacity = '0';
                    internshipsTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        internshipsTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show experiences
                if (experiencesTimeline) {
                    setTimeout(() => {
                        experiencesTimeline.style.display = 'block';
                        setTimeout(() => {
                            experiencesTimeline.style.opacity = '1';
                            experiencesTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            } else if (category === 'internships') {
                // Hide experiences
                if (experiencesTimeline) {
                    experiencesTimeline.style.opacity = '0';
                    experiencesTimeline.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        experiencesTimeline.style.display = 'none';
                    }, 300);
                }
                
                // Show internships
                if (internshipsTimeline) {
                    setTimeout(() => {
                        internshipsTimeline.style.display = 'block';
                        setTimeout(() => {
                            internshipsTimeline.style.opacity = '1';
                            internshipsTimeline.style.transform = 'translateY(0)';
                        }, 50);
                    }, 300);
                }
            }
        });
    });
    
    // Initialize timeline animations
    const expTimelines = [experiencesTimeline, internshipsTimeline];
    expTimelines.forEach(timeline => {
        if (timeline) {
            timeline.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            timeline.style.opacity = timeline.id === 'experiences-timeline' ? '1' : '0';
            timeline.style.transform = 'translateY(0)';
        }
    });
});

// Testimonials Slider
document.addEventListener('DOMContentLoaded', function() {
    const slider = document.querySelector('.testimonials-slider');
    if (!slider) return;

    const track = slider.querySelector('.testimonials-track');
    const cards = slider.querySelectorAll('.testimonial-card');
    const prevBtn = slider.querySelector('.slider-btn.prev');
    const nextBtn = slider.querySelector('.slider-btn.next');
    const indicators = slider.querySelectorAll('.indicator');
    
    let currentIndex = 0;
    const totalCards = cards.length;
    let autoplayInterval = null;
    let progressInterval = null;
    let isPaused = false;
    let pausedProgress = 0;
    
    // Barre de progression
    const progressContainer = slider.querySelector('.autoplay-progress-container');
    const progressBar = slider.querySelector('.autoplay-progress-bar');

    // Function to update slider position
    function updateSlider() {
        if (track) {
            const translateX = -currentIndex * 100;
            track.style.transform = `translateX(${translateX}%)`;
        }
        
        // Update indicators
        indicators.forEach((indicator, index) => {
            indicator.classList.toggle('active', index === currentIndex);
        });
        
        // Update button states
        if (prevBtn) prevBtn.disabled = currentIndex === 0;
        if (nextBtn) nextBtn.disabled = currentIndex === totalCards - 1;
    }

    // Function to start autoplay with synchronized progress bar
    function startAutoplay() {
        // Clear any existing intervals
        if (autoplayInterval) {
            clearInterval(autoplayInterval);
        }
        if (progressInterval) {
            clearInterval(progressInterval);
        }
        
        // Reset progress bar if not resuming from pause
        if (!isPaused && progressBar) {
            progressBar.style.width = '0%';
            pausedProgress = 0;
        }
        
        // Unified timer for both progress and slide change
        let progress = isPaused ? pausedProgress : 0;
        const totalDuration = 5000; // 5 seconds
        const updateFrequency = 50; // Update every 50ms for smooth animation
        const increment = (100 / totalDuration) * updateFrequency; // Progress increment per update
        
        autoplayInterval = setInterval(() => {
            // Only update if not paused (local OR global)
            if (!isPaused && !window.testimonialsGlobalPause) {
                progress += increment;
                
                // Update progress bar
                if (progressBar) {
                    progressBar.style.width = `${Math.min(progress, 100)}%`;
                }
                
                // Store current progress in case of pause
                pausedProgress = progress;
                
                // When progress reaches 100%, change slide and restart
                if (progress >= 100) {
                    // Clear current interval to prevent overlap
                    clearInterval(autoplayInterval);
                    
                    // Change slide
                    if (currentIndex < totalCards - 1) {
                        currentIndex++;
                    } else {
                        currentIndex = 0;
                    }
                    
                    // Update slider immediately
                    updateSlider();
                    
                    // Reset progress for next cycle
                    progress = 0;
                    pausedProgress = 0;
                    if (progressBar) {
                        progressBar.style.width = '0%';
                    }
                    
                    // Start next cycle after a small delay to ensure DOM update
                    setTimeout(() => {
                        if (!isPaused) {
                            startAutoplay();
                        }
                    }, 100);
                    
                    return; // Exit current interval
                }
            }
        }, updateFrequency);
    }

    // Function to pause autoplay
    function pauseAutoplay() {
        isPaused = true;
    }

    // Function to resume autoplay
    function resumeAutoplay() {
        isPaused = false;
    }

    // Function to reset autoplay (restart the timer)
    function resetAutoplay() {
        // Clear existing intervals
        if (autoplayInterval) {
            clearInterval(autoplayInterval);
        }
        if (progressInterval) {
            clearInterval(progressInterval);
        }
        
        isPaused = false;
        pausedProgress = 0;
        
        // Reset progress bar
        if (progressBar) {
            progressBar.style.width = '0%';
        }
        
        // Start autoplay after a short delay
        setTimeout(() => {
            startAutoplay();
        }, 50);
    }

    // Next button
    nextBtn.addEventListener('click', () => {
        if (currentIndex < totalCards - 1) {
            currentIndex++;
            updateSlider();
            resetAutoplay(); // Reset the autoplay timer
        }
    });

    // Previous button
    prevBtn.addEventListener('click', () => {
        if (currentIndex > 0) {
            currentIndex--;
            updateSlider();
            resetAutoplay(); // Reset the autoplay timer
        }
    });

    // Indicator clicks
    indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => {
            currentIndex = index;
            updateSlider();
            resetAutoplay(); // Reset the autoplay timer
        });
    });

    // Start autoplay
    startAutoplay();

    // Initialize slider
    updateSlider();

    // Mouse hover events for pause/resume on testimonial cards only
    cards.forEach(card => {
        card.addEventListener('mouseenter', () => {
            pauseAutoplay();
        });

        card.addEventListener('mouseleave', () => {
            resumeAutoplay();
        });
    });

    // Touch/swipe support for mobile
    let startX = null;
    let startY = null;

    slider.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });

    slider.addEventListener('touchmove', (e) => {
        if (!startX || !startY) return;
        
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        
        const diffX = startX - currentX;
        const diffY = startY - currentY;
        
        // Only handle horizontal swipes
        if (Math.abs(diffX) > Math.abs(diffY)) {
            e.preventDefault();
        }
    });

    slider.addEventListener('touchend', (e) => {
        if (!startX || !startY) return;
        
        const endX = e.changedTouches[0].clientX;
        const diffX = startX - endX;
        
        // Minimum swipe distance
        if (Math.abs(diffX) > 50) {
            if (diffX > 0 && currentIndex < totalCards - 1) {
                // Swipe left - next slide
                currentIndex++;
                updateSlider();
                resetAutoplay(); // Reset the autoplay timer
            } else if (diffX < 0 && currentIndex > 0) {
                // Swipe right - previous slide
                currentIndex--;
                updateSlider();
                resetAutoplay(); // Reset the autoplay timer
            }
        }
        
        startX = null;
        startY = null;
    });
    
    // Enregistrer ce slider dans le syst√®me global de contr√¥le des t√©moignages
    if (slider) {
        const mainSliderController = {
            pauseRotation: pauseAutoplay,
            resumeRotation: resumeAutoplay,
            stopRotation: () => {
                if (autoplayInterval) {
                    clearInterval(autoplayInterval);
                    autoplayInterval = null;
                }
                isPaused = false;
                pausedProgress = 0;
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
            },
            startRotation: startAutoplay,
            container: slider
        };
        
        // Enregistrer ce controller dans la liste globale
        window.testimonialsControllers.push(mainSliderController);
    }
});

// Contact Form Functionality
document.addEventListener('DOMContentLoaded', function() {
    const contactForm = document.getElementById('contactForm');
    
    if (contactForm) {
        contactForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Get form data
            const formData = new FormData(contactForm);
            const name = formData.get('name');
            const email = formData.get('email');
            const subject = formData.get('subject');
            const message = formData.get('message');
            
            // Basic validation
            if (!name || !email || !message) {
                showNotification('Veuillez remplir tous les champs requis.', 'error');
                return;
            }
            
            // Email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                showNotification('Veuillez entrer une adresse email valide.', 'error');
                return;
            }
            
            // Show loading state
            const submitBtn = contactForm.querySelector('.submit-btn');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '<span>Envoi en cours...</span><div class="btn-icon">‚è≥</div>';
            submitBtn.disabled = true;
            
            // Simulate form submission (replace with actual form handling)
            setTimeout(() => {
                // Create mailto link as fallback
                const mailtoLink = `mailto:clement.g.developer@gmail.com?subject=${encodeURIComponent(subject || 'Contact depuis le portfolio')}&body=${encodeURIComponent(`Nom: ${name}\nEmail: ${email}\n\nMessage:\n${message}`)}`;
                
                // Open default email client
                window.location.href = mailtoLink;
                
                // Reset form
                contactForm.reset();
                
                // Reset button
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;
                
                // Show success message
                showNotification('Votre message a √©t√© pr√©par√© dans votre client email !', 'success');
            }, 1000);
        });
    }
    
    // Form field animations
    const formInputs = document.querySelectorAll('.contact-form input, .contact-form select, .contact-form textarea');
    
    formInputs.forEach(input => {
        input.addEventListener('focus', function() {
            this.parentElement.classList.add('focused');
        });
        
        input.addEventListener('blur', function() {
            if (!this.value) {
                this.parentElement.classList.remove('focused');
            }
        });
        
        // Check if field has value on page load
        if (input.value) {
            input.parentElement.classList.add('focused');
        }
    });
});

// Notification system - Utilise le syst√®me du right-dock si disponible
function showNotification(message, type = 'info') {
    // V√©rifier si le syst√®me de notifications du right-dock est disponible
    if (window.rightDockManager && window.rightDockManager.showNotification) {
        window.rightDockManager.showNotification(message, type);
        return;
    }
    
    // Fallback : syst√®me de notifications simple
    // Remove existing notifications
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => notification.remove());
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
        <div class="notification-content">
            <span class="notification-icon">${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}</span>
            <span class="notification-message">${message}</span>
            <button class="notification-close" onclick="this.parentElement.parentElement.remove()">‚úï</button>
        </div>
    `;
    
    // Add styles for notification
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? 'rgba(34, 197, 94, 0.9)' : type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(59, 130, 246, 0.9)'};
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 1rem;
        color: white;
        z-index: 10000;
        animation: slideInRight 0.3s ease;
        max-width: 400px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    `;
    
    // Add notification styles to document if not already present
    if (!document.querySelector('#notification-styles')) {
        const style = document.createElement('style');
        style.id = 'notification-styles';
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            .notification-content {
                display: flex;
                align-items: center;
                gap: 0.75rem;
            }
            
            .notification-close {
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 1.2rem;
                padding: 0;
                margin-left: auto;
                opacity: 0.7;
                transition: opacity 0.2s ease;
            }
            
            .notification-close:hover {
                opacity: 1;
            }
            
            .notification-icon {
                font-size: 1.2rem;
            }
            
            .notification-message {
                flex: 1;
                font-size: 0.95rem;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add to page
    document.body.appendChild(notification);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.style.animation = 'slideInRight 0.3s ease reverse';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}

// Project Actions - Show More functionality
function showMoreActions(button) {
    console.log('showMoreActions called', button);
    
    // Trouver la popup associ√©e √† ce bouton
    // Remonter jusqu'au conteneur des actions du projet
    let container = button.parentElement;
    let popup = null;
    
    // Chercher la popup dans le conteneur direct
    popup = container.querySelector('.actions-popup');
    
    // Si pas trouv√©, remonter d'un niveau (au cas o√π la structure serait diff√©rente)
    if (!popup && container.parentElement) {
        popup = container.parentElement.querySelector('.actions-popup');
    }
    
    // Si toujours pas trouv√©, chercher dans tout le projet
    if (!popup) {
        const projectContainer = button.closest('.project-item, .project-detail, .project-single');
        if (projectContainer) {
            popup = projectContainer.querySelector('.actions-popup');
        }
    }
    
    console.log('popup found:', popup);
    
    if (popup) {
        // S'assurer que le popup a les bonnes propri√©t√©s CSS pour le centrage
        popup.style.display = 'flex';
        popup.style.position = 'fixed';
        popup.style.top = '0';
        popup.style.left = '0';
        popup.style.width = '100%';
        popup.style.height = '100%';
        popup.style.alignItems = 'center';
        popup.style.justifyContent = 'center';
        popup.style.zIndex = '9999';
        
        document.body.style.overflow = 'hidden';
        console.log('popup shown and centered');
    } else {
        console.error('Popup not found!');
        console.log('Button parent:', button.parentElement);
        console.log('Button parent children:', button.parentElement.children);
        // Afficher toutes les popups disponibles pour debug
        console.log('All actions-popup elements:', document.querySelectorAll('.actions-popup'));
    }
}

// G√©rer les actions YouTube avec le viewer int√©gr√©
function handleYouTubeAction(url, title) {
    console.log('handleYouTubeAction called with URL:', url, 'Title:', title);
    
    // Ajouter un indicateur de chargement
    const loadingIndicator = document.createElement('div');
    loadingIndicator.className = 'youtube-loading-indicator';
    loadingIndicator.innerHTML = 'üé• Ouverture du viewer...';
    loadingIndicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        z-index: 10001;
        font-size: 14px;
        backdrop-filter: blur(10px);
        animation: fadeIn 0.3s ease;
    `;
    
    document.body.appendChild(loadingIndicator);
    
    try {
        // Extraire l'ID vid√©o de l'URL YouTube
        const videoId = extractYouTubeVideoId(url);
        
        if (videoId) {
            // Fermer d'abord le popup des actions
            hideMoreActions(document.querySelector('.actions-popup'));
            
            setTimeout(() => {
                openYouTubeModal(videoId, title);
                if (loadingIndicator.parentElement) {
                    document.body.removeChild(loadingIndicator);
                }
            }, 500);
        } else {
            console.warn('Cannot extract YouTube video ID from URL:', url, '- opening in new tab');
            if (loadingIndicator.parentElement) {
                document.body.removeChild(loadingIndicator);
            }
            
            // Fallback: ouvrir dans un nouvel onglet
            setTimeout(() => window.open(url, '_blank'), 300);
        }
    } catch (error) {
        console.error('Error handling YouTube action:', error);
        if (loadingIndicator.parentElement) {
            document.body.removeChild(loadingIndicator);
        }
        // Fallback en cas d'erreur
        setTimeout(() => window.open(url, '_blank'), 300);
    }
}

// Extraire l'ID vid√©o YouTube de diff√©rents formats d'URL
function extractYouTubeVideoId(url) {
    // Diff√©rents formats d'URL YouTube
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/watch\?.*v=([^&\n?#]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
    }
    
    return null;
}

function hideMoreActions(element) {
    // Remonter jusqu'√† trouver la popup
    let popup = element.closest('.actions-popup');
    if (!popup) {
        popup = element.parentElement.querySelector('.actions-popup');
    }
    
    if (popup) {
        popup.style.display = 'none';
        document.body.style.overflow = '';
    }
}

// Fermer le popup avec Escape
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const openPopup = document.querySelector('.actions-popup[style*="flex"]');
        if (openPopup) {
            hideMoreActions(openPopup);
        }
    }
});

/**
 * PROJECT HERO BLUR EFFECT
 * 
 * G√®re l'effet de blur progressif du background hero quand on scroll
 * vers la section de contenu texte
 */
document.addEventListener('DOMContentLoaded', function() {
    const projectHero = document.querySelector('.project-hero');
    const transitionElement = document.querySelector('.hero-to-content-transition');
    
    if (!projectHero || !transitionElement) return;
    
    // R√©cup√®re l'image de fond du hero et l'applique au body
    const heroStyle = window.getComputedStyle(projectHero);
    const bgImage = heroStyle.backgroundImage;
    
    if (bgImage && bgImage !== 'none') {
        document.body.style.setProperty('--hero-bg-image', bgImage);
    }
    
    function updateBlurEffect() {
        const scrollY = window.scrollY;
        const heroHeight = projectHero.offsetHeight;
        const windowHeight = window.innerHeight;
        
        // Calcule quand commencer l'effet (quand on commence √† voir la transition)
        const transitionStart = heroHeight - windowHeight * 0.3;
        const transitionEnd = heroHeight + 300; // Un peu apr√®s le d√©but de la transition
        
        // Calcule le pourcentage de progression
        let blurProgress = 0;
        if (scrollY >= transitionStart && scrollY <= transitionEnd) {
            blurProgress = (scrollY - transitionStart) / (transitionEnd - transitionStart);
            blurProgress = Math.max(0, Math.min(1, blurProgress)); // Clamp entre 0 et 1
        } else if (scrollY > transitionEnd) {
            blurProgress = 1;
        }
        
        // Applique une courbe d'easing pour un effet plus naturel
        const easeOutCubic = 1 - Math.pow(1 - blurProgress, 3);
        
        // Calcule les valeurs finales
        const blurValue = easeOutCubic * 20; // Maximum 20px de blur
        const transitionBlur = easeOutCubic * 5; // Maximum 5px pour la transition
        
        // Applique les effets sur le body (background fixe)
        document.body.style.setProperty('--blur-intensity', `${blurValue}px`);
        
        // Applique sur la transition
        transitionElement.style.setProperty('--transition-blur', `${transitionBlur}px`);
    }
    
    // √âv√©nements de scroll optimis√©s avec throttling
    let ticking = false;
    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(() => {
                updateBlurEffect();
                ticking = false;
            });
            ticking = true;
        }
    }
    
    window.addEventListener('scroll', requestTick, { passive: true });
    window.addEventListener('resize', requestTick, { passive: true });
    
    // Initialisation
    updateBlurEffect();
});

// ========================================
// TESTIMONIALS ROTATOR FUNCTIONALITY
// ========================================

// Variables globales pour contr√¥ler tous les t√©moignages
window.testimonialsGlobalPause = false;
window.testimonialsControllers = [];

// Fonctions globales pour contr√¥ler tous les t√©moignages
window.pauseAllTestimonials = function() {
    window.testimonialsGlobalPause = true;
    window.testimonialsControllers.forEach(controller => {
        if (controller.pauseRotation) {
            controller.pauseRotation();
        }
    });
    
    // Pause education testimonials
    if (window.educationTestimonialsPausers) {
        window.educationTestimonialsPausers.forEach(pauser => {
            if (pauser.pause) {
                pauser.pause();
            }
        });
    }
};

window.resumeAllTestimonials = function() {
    window.testimonialsGlobalPause = false;
    window.testimonialsControllers.forEach(controller => {
        if (controller.resumeRotation) {
            controller.resumeRotation();
        }
    });
    
    // Resume education testimonials
    if (window.educationTestimonialsPausers) {
        window.educationTestimonialsPausers.forEach(pauser => {
            if (pauser.resume) {
                pauser.resume();
            }
        });
    }
};

// Gestion de la rotation des testimonials
function initTestimonialsRotator() {
    const previewContainers = document.querySelectorAll('.widget-testimonials-rotator');
    
    previewContainers.forEach(container => {
        const items = container.querySelectorAll('.widget-testimonial-preview-item');
        const progressBar = container.parentElement.querySelector('.widget-testimonials-progress');
        
        if (items.length <= 1) return;
        
        let currentIndex = 0;
        let intervalId;
        let progressAnimationId;
        let isPaused = false;
        let pausedProgress = 0;
        
        function showTestimonial(index) {
            // Masquer tous les testimonials
            items.forEach(item => item.classList.remove('active'));
            
            // Afficher le testimonial √† l'index donn√©
            if (items[index]) {
                items[index].classList.add('active');
            }
        }
        
        function startProgressCycle() {
            if (!progressBar) return;
            
            // Supprimer l'animation CSS pour utiliser JS
            progressBar.style.animation = 'none';
            
            let progress = isPaused ? pausedProgress : 0;
            const duration = 6000; // 6 secondes
            const interval = 16; // Mise √† jour toutes les 16ms (60fps)
            const increment = (100 / duration) * interval;
            
            // Si on reprend depuis une pause, ne pas r√©initialiser la barre
            if (!isPaused) {
                progressBar.style.setProperty('--progress-width', '0%');
            }
            
            progressAnimationId = setInterval(() => {
                // Ne progresser que si pas en pause (locale OU globale)
                if (!isPaused && !window.testimonialsGlobalPause) {
                    progress += increment;
                    pausedProgress = progress;
                    
                    // Mettre √† jour la largeur via CSS custom property
                    progressBar.style.setProperty('--progress-width', Math.min(progress, 100) + '%');
                    
                    // Quand on atteint 100%, passer au suivant
                    if (progress >= 100) {
                        clearInterval(progressAnimationId);
                        
                        // Changer de testimonial
                        currentIndex = (currentIndex + 1) % items.length;
                        showTestimonial(currentIndex);
                        
                        // Red√©marrer le cycle apr√®s un petit d√©lai
                        setTimeout(() => {
                            if (progressAnimationId !== null) { // V√©rifier qu'on n'a pas √©t√© arr√™t√© entre temps
                                pausedProgress = 0;
                                isPaused = false;
                                startProgressCycle();
                            }
                        }, 100);
                    }
                }
            }, interval);
        }
        
        function showNextTestimonial() {
            // Fonction helper pour changement manuel
            currentIndex = (currentIndex + 1) % items.length;
            showTestimonial(currentIndex);
        }
        
        function startRotation() {
            // Arr√™ter toute rotation existante pour √©viter les conflits
            stopRotation();
            
            // S'assurer que le premier testimonial est affich√©
            showTestimonial(0);
            currentIndex = 0;
            
            // D√©marrer le cycle de progression unifi√©
            startProgressCycle();
        }
        
        function pauseRotation() {
            isPaused = true;
        }
        
        function resumeRotation() {
            isPaused = false;
        }
        
        function stopRotation() {
            // Arr√™ter l'animation de progression
            if (progressAnimationId) {
                clearInterval(progressAnimationId);
                progressAnimationId = null;
            }
            
            // R√©initialiser l'√©tat
            isPaused = false;
            pausedProgress = 0;
            
            // R√©initialiser la barre de progression
            if (progressBar) {
                progressBar.style.setProperty('--progress-width', '0%');
            }
        }
        
        // V√©rifier si le conteneur est visible
        function checkVisibility() {
            const infoBox = container.closest('.info-box');
            const isTestimonialsBox = infoBox && infoBox.classList.contains('widget-testimonials-box');
            
            // Pour la testimonials-box, d√©marrer la rotation seulement si ferm√©e
            if (isTestimonialsBox) {
                const isExpanded = infoBox.classList.contains('expanded');
                if (!isExpanded) {
                    startRotation();
                } else {
                    stopRotation();
                }
                return;
            }
            
            // Pour les autres boxes, v√©rifier l'√©tat expanded
            const isExpanded = infoBox && infoBox.classList.contains('expanded');
            
            if (!isExpanded && container.offsetParent !== null) {
                startRotation();
            } else {
                stopRotation();
            }
        }
        
        // Observer les changements de classe expanded
        const infoBox = container.closest('.info-box');
        if (infoBox) {
            const observer = new MutationObserver(() => {
                setTimeout(checkVisibility, 100); // Petit d√©lai pour laisser le CSS s'appliquer
            });
            
            observer.observe(infoBox, {
                attributes: true,
                attributeFilter: ['class']
            });
            
            // Ajouter les √©v√©nements de survol pour faire pause/reprendre
            infoBox.addEventListener('mouseenter', () => {
                if (progressAnimationId && !infoBox.classList.contains('expanded')) {
                    pauseRotation();
                }
            });
            
            infoBox.addEventListener('mouseleave', () => {
                if (progressAnimationId && !infoBox.classList.contains('expanded')) {
                    resumeRotation();
                }
            });
        }
        
        // Cr√©er un controller pour ce widget et l'enregistrer globalement
        const controller = {
            pauseRotation: pauseRotation,
            resumeRotation: resumeRotation,
            stopRotation: stopRotation,
            startRotation: startRotation,
            container: container
        };
        
        // Enregistrer ce controller dans la liste globale
        window.testimonialsControllers.push(controller);
        
        // D√©marrer imm√©diatement si visible
        setTimeout(checkVisibility, 500); // D√©lai initial pour s'assurer que le DOM est pr√™t
    });
}
// ========================================
// INFO BOX TOGGLE FUNCTIONALITY
// ========================================
// Toggle ouvert/ferm√© pour les info-box
function toggleInfoBox(headerElem) {
    const box = headerElem.closest('.info-box');
    if (box) {
        box.classList.toggle('expanded');
    }
}

// ========================================
// YOUTUBE MODAL FUNCTIONALITY
// ========================================

// Ouvrir le modal YouTube
function openYouTubeModal(videoId, title) {
    const modal = document.getElementById('youtubeModal');
    const iframe = document.getElementById('youtubeIframe');
    const modalContent = modal.querySelector('.youtube-modal-content');
    
    if (modal && iframe && modalContent) {
        // Afficher l'indicateur de chargement
        modalContent.classList.add('loading');
        
        // D√©finir la source de l'iframe
        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0&modestbranding=1`;
        
        // Pause all testimonials before showing modal
        if (typeof window.pauseAllTestimonials === 'function') {
            window.pauseAllTestimonials();
        }
        
        // Afficher le modal
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Masquer l'indicateur de chargement apr√®s un d√©lai
        setTimeout(() => {
            modalContent.classList.remove('loading');
        }, 1000);
        
        // √âcouter l'√©v√©nement de chargement de l'iframe
        iframe.onload = function() {
            modalContent.classList.remove('loading');
        };
    }
}

// Fermer le modal YouTube
function closeYouTubeModal() {
    const modal = document.getElementById('youtubeModal');
    const iframe = document.getElementById('youtubeIframe');
    const modalContent = modal.querySelector('.youtube-modal-content');
    
    if (modal && iframe && modalContent) {
        // Resume all testimonials when closing modal
        if (typeof window.resumeAllTestimonials === 'function') {
            window.resumeAllTestimonials();
        }
        
        modal.classList.remove('active');
        
        // D√©lai pour laisser l'animation se terminer avant de supprimer la source
        setTimeout(() => {
            iframe.src = '';
            modalContent.classList.remove('loading');
        }, 300);
        
        document.body.style.overflow = '';
    }
}

// Fermer le modal avec la touche √âchap
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        closeYouTubeModal();
    }
});

// ========================================
// INITIALIZATION
// ========================================

// Initialiser toutes les fonctionnalit√©s au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser le rotateur de testimonials
    initTestimonialsRotator();
    
    // Pr√©venir la propagation des clics sur le contenu du modal
    const modalContent = document.querySelector('.youtube-modal-content');
    if (modalContent) {
        modalContent.addEventListener('click', function(e) {
            e.stopPropagation();
        });
    }

    // Initialiser le filtrage des comp√©tences
    initSkillsFiltering();
});

// Skills filtering functionality
function initSkillsFiltering() {
    const skillCategoryBtns = document.querySelectorAll('.skill-category-btn');
    const skillCategories = document.querySelectorAll('.skills-category');
    const skillsDescription = document.getElementById('skills-section-description');
    
    if (!skillCategoryBtns.length || !skillCategories.length) return;
    
    const skillDescriptions = {
        all: "Explorez toutes mes comp√©tences techniques organis√©es par cat√©gories. Cliquez sur une cat√©gorie pour filtrer les comp√©tences.",
        "programming-languages": "Langages de programmation que je ma√Ætrise, du niveau d√©butant √† expert selon mon exp√©rience pratique.",
        frameworks: "Frameworks et biblioth√®ques que j'utilise pour d√©velopper des applications robustes et performantes.",
        engines: "Moteurs de jeu et environnements de d√©veloppement pour la cr√©ation d'exp√©riences interactives.",
        environments: "Environnements de d√©veloppement int√©gr√©s (IDE) et √©diteurs de code que j'utilise au quotidien.",
        tools: "Outils de d√©veloppement, gestion de versions, cloud, design et autres utilitaires professionnels.",
        specialties: "Domaines de sp√©cialisation et expertises techniques sp√©cifiques √† mon profil.",
        "soft-skills": "Comp√©tences comportementales et relationnelles essentielles dans le travail en √©quipe."
    };
    
    skillCategoryBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active button
            skillCategoryBtns.forEach(button => button.classList.remove('active'));
            btn.classList.add('active');
            
            // Update description
            if (skillsDescription && skillDescriptions[category]) {
                skillsDescription.textContent = skillDescriptions[category];
            }
            
            // Show/hide skill categories
            skillCategories.forEach(skillCategory => {
                if (category === 'all') {
                    skillCategory.style.display = 'block';
                } else if (skillCategory.getAttribute('data-category') === category) {
                    skillCategory.style.display = 'block';
                } else {
                    skillCategory.style.display = 'none';
                }
            });
        });
    });
    
    // Initialize with "all" category active
    const allButton = document.querySelector('.skill-category-btn[data-category="all"]');
    if (allButton && !document.querySelector('.skill-category-btn.active')) {
        allButton.click();
    }
}
