console.log('This site was generated by Hugo.');

// Projects Section Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Tab switching functionality
    const tabBtns = document.querySelectorAll('.tab-btn');
    const projectCards = document.querySelectorAll('.project-card');
    const sectionDescription = document.getElementById('section-description');
    
    const descriptions = {
        projects: "This section contains the projects completed by me, using major Technologies.",
        achievements: "Recognition and certifications earned throughout my professional journey.",
        hobbies: "Personal projects and interests that fuel my passion for development."
    };
    
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const category = btn.getAttribute('data-category');
            
            // Update active tab
            tabBtns.forEach(tab => tab.classList.remove('active'));
            btn.classList.add('active');
            
            // Update description
            if (sectionDescription) {
                sectionDescription.textContent = descriptions[category];
            }
            
            // Show/hide cards based on category
            projectCards.forEach(card => {
                if (card.getAttribute('data-category') === category) {
                    card.style.display = 'block';
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0)';
                    }, 50);
                } else {
                    card.style.opacity = '0';
                    card.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        card.style.display = 'none';
                    }, 300);
                }
            });
            
            // Reset tech filter
            const techBadges = document.querySelectorAll('.tech-badge');
            techBadges.forEach(badge => badge.classList.remove('active'));
            document.querySelector('.tech-badge[data-tech="all"]').classList.add('active');
        });
    });
    
    // Technology filter functionality
    const techBadges = document.querySelectorAll('.tech-badge');
    
    techBadges.forEach(badge => {
        badge.addEventListener('click', () => {
            const tech = badge.getAttribute('data-tech');
            const activeCategory = document.querySelector('.tab-btn.active').getAttribute('data-category');
            
            // Update active badge
            techBadges.forEach(b => b.classList.remove('active'));
            badge.classList.add('active');
            
            // Filter cards
            const categoryCards = document.querySelectorAll(`[data-category="${activeCategory}"]`);
            
            categoryCards.forEach(card => {
                const cardTechnologies = card.getAttribute('data-technologies');
                
                if (tech === 'all' || (cardTechnologies && cardTechnologies.includes(tech))) {
                    card.style.display = 'block';
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0)';
                    }, 50);
                } else {
                    card.style.opacity = '0';
                    card.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        card.style.display = 'none';
                    }, 300);
                }
            });
        });
    });
    
    // Initialize card animations
    projectCards.forEach(card => {
        card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    });
});

// Testimonials Slider
document.addEventListener('DOMContentLoaded', function() {
    const slider = document.querySelector('.testimonials-slider');
    if (!slider) return;

    const track = slider.querySelector('.testimonials-track');
    const cards = slider.querySelectorAll('.testimonial-card');
    const prevBtn = slider.querySelector('.slider-btn.prev');
    const nextBtn = slider.querySelector('.slider-btn.next');
    const indicators = slider.querySelectorAll('.indicator');
    
    let currentIndex = 0;
    const totalCards = cards.length;

    // Function to update slider position
    function updateSlider() {
        const translateX = -currentIndex * 100;
        track.style.transform = `translateX(${translateX}%)`;
        
        // Update indicators
        indicators.forEach((indicator, index) => {
            indicator.classList.toggle('active', index === currentIndex);
        });
        
        // Update button states
        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === totalCards - 1;
    }

    // Next button
    nextBtn.addEventListener('click', () => {
        if (currentIndex < totalCards - 1) {
            currentIndex++;
            updateSlider();
        }
    });

    // Previous button
    prevBtn.addEventListener('click', () => {
        if (currentIndex > 0) {
            currentIndex--;
            updateSlider();
        }
    });

    // Indicator clicks
    indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => {
            currentIndex = index;
            updateSlider();
        });
    });

    // Auto-play slider
    setInterval(() => {
        if (currentIndex < totalCards - 1) {
            currentIndex++;
        } else {
            currentIndex = 0;
        }
        updateSlider();
    }, 5000); // Change slide every 5 seconds

    // Initialize slider
    updateSlider();

    // Touch/swipe support for mobile
    let startX = null;
    let startY = null;

    slider.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });

    slider.addEventListener('touchmove', (e) => {
        if (!startX || !startY) return;
        
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;
        
        const diffX = startX - currentX;
        const diffY = startY - currentY;
        
        // Only handle horizontal swipes
        if (Math.abs(diffX) > Math.abs(diffY)) {
            e.preventDefault();
        }
    });

    slider.addEventListener('touchend', (e) => {
        if (!startX || !startY) return;
        
        const endX = e.changedTouches[0].clientX;
        const diffX = startX - endX;
        
        // Minimum swipe distance
        if (Math.abs(diffX) > 50) {
            if (diffX > 0 && currentIndex < totalCards - 1) {
                // Swipe left - next slide
                currentIndex++;
                updateSlider();
            } else if (diffX < 0 && currentIndex > 0) {
                // Swipe right - previous slide
                currentIndex--;
                updateSlider();
            }
        }
        
        startX = null;
        startY = null;
    });
});
