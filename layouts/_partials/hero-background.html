<!-- Hero Background - Deep Space Aesthetic with Luminous Ribbon -->
<div id="hero-background" class="hero-background">
  <!-- Canvas for particles -->
  <canvas id="particles-canvas"></canvas>
  
  <!-- SVG masks for organic shapes -->
  <svg style="position: absolute; width: 0; height: 0;" aria-hidden="true">
    <defs>
      <mask id="organic-mask-1">
        <path d="M 0,0 L 100,0 Q 90,15 100,30 Q 85,45 100,60 Q 95,75 100,90 L 100,100 L 0,100 Q 15,85 0,70 Q 25,55 0,40 Q 10,25 0,10 Z" fill="white" transform="scale(5,0.8)"/>
      </mask>
      <mask id="organic-mask-2">
        <path d="M 0,0 L 100,0 Q 95,20 100,35 Q 80,50 100,65 Q 92,80 100,95 L 100,100 L 0,100 Q 20,80 0,65 Q 30,50 0,35 Q 8,20 0,5 Z" fill="white" transform="scale(5,0.8)"/>
      </mask>
      <mask id="organic-mask-3">
        <path d="M 0,0 L 100,0 Q 88,25 100,40 Q 78,55 100,70 Q 90,85 100,100 L 0,100 Q 22,75 0,60 Q 35,45 0,30 Q 12,15 0,0 Z" fill="white" transform="scale(5,0.8)"/>
      </mask>
    </defs>
  </svg>

  <!-- Canvas for fluid waves Paper.js -->
  <canvas id="waves-canvas"></canvas>
</div>

<!-- Inline styles for hero background -->
<style>
/* .hero-background styles */
.hero-background {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
  overflow: hidden;
  
  /* Radial + linear gradient as per exact specifications */
  background: 
    /* Very wide radial gradient for main glow */
    radial-gradient(ellipse 280% 280% at 50% 25%, 
      rgba(10, 30, 84, 0.8) 0%,     /* #0A1E54 - Center */
      rgba(16, 41, 101, 0.6) 25%,   /* #102965 */
      rgba(20, 51, 122, 0.4) 50%,   /* #14337A */
      rgba(27, 70, 144, 0.2) 75%,   /* #1B4690 */
      transparent 100%
    ),
    /* Vertical linear gradient for depth */
    linear-gradient(to bottom, 
      #0A1E54 0%,    /* Saturated night blue */
      #102965 25%, 
      #14337A 50%, 
      #1B4690 75%, 
      #2449B2 100%   /* Extreme bottom */
    );
  
  /* Performance optimization */
  will-change: transform;
  backface-visibility: hidden;
  transform: translateZ(0);
}

/* Canvas for fluid waves Paper.js */
#waves-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 2;
  opacity: 0.8;
  mix-blend-mode: screen;
}

/* Canvas for particles */
#particles-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

/* Global performance optimizations */
.hero-background * {
  will-change: transform, opacity;
}

/* Responsive Design - Optimized */
@media (max-width: 1200px) {
  .hero-background { background-size: 120% 120%; }
  .ribbon-main { height: 100px; top: 38%; }
  .ribbon-secondary-1 { height: 70px; top: 33%; }
  .ribbon-secondary-2 { height: 50px; top: 40%; }
  .ribbon-tertiary { height: 35px; top: 36%; }
}

@media (max-width: 768px) {
  .hero-background { background-size: 150% 150%; }
  .ribbon-main { height: 80px; top: 40%; }
  .ribbon-secondary-1 { height: 60px; top: 36%; }
  .ribbon-secondary-2 { height: 40px; top: 42%; }
  .ribbon-tertiary { height: 30px; top: 38%; }
}

@media (max-width: 480px) {
  .hero-background { 
    background-size: 200% 200%; 
    background-position: center top; 
  }
  .ribbon-main { height: 60px; top: 42%; }
  .ribbon-secondary-1 { height: 45px; top: 38%; }
  .ribbon-secondary-2 { height: 35px; top: 44%; }
  .ribbon-tertiary { height: 25px; top: 40%; }
}

/* Reduced motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  #waves-canvas { display: none; }
  #particles-canvas { display: none; }
}

/* Performance for high resolution screens */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .hero-background { background-attachment: fixed; }
}
</style>

<!-- Script for fluid waves Paper.js and particles -->
<script src="https://unpkg.com/paper@0.12.17/dist/paper-full.min.js"></script>
<script>
// Check if animations are allowed
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

if (!prefersReducedMotion) {
  document.addEventListener('DOMContentLoaded', function() {
    
    /**
     * Fluid waves system inspired by Paper.js
     */
    class FluidWaves {
      constructor() {
        this.canvas = document.getElementById('waves-canvas');
        if (!this.canvas) {
          console.warn('Canvas waves-canvas not found');
          return;
        }
        
        // Initialize Paper.js
        paper.setup(this.canvas);
        
        // Waves configuration
        this.h = window.innerHeight;
        this.w = window.innerWidth;
        this.halfH = this.h * 0.5;
        this.speed = 0.12; // Slower for smoothness
        this.strokeWidth = 70;
        this.frequency = 3;
        this.pathCount = 7; // More waves
        this.pathPoints = 24; // More points for smoothness
        
        this.paths = [];
        this.offsetRandom = 3;
        this.randomOffsets = [];
        this.maxDistRandom = 1.2;
        this.randomDistances = [];
        this.randomHeights = [];
        this.magnitude = 0.15; // Wave amplitude
        
        // PS3 style colors
        this.colors = [
          'rgba(255, 255, 255, 0.4)',
          'rgba(200, 240, 255, 0.3)',
          'rgba(180, 230, 255, 0.35)',
          'rgba(150, 220, 255, 0.25)',
          'rgba(120, 200, 255, 0.2)',
          'rgba(100, 180, 255, 0.15)',
          'rgba(80, 160, 255, 0.1)'
        ];
        
        this.init();
      }
      
      init() {
        this.createWaves();
        this.setupEvents();
        this.animate();
      }
      
      createWaves() {
        // Clean up old waves
        if (this.paths.length > 0) {
          this.paths.forEach(path => path.remove());
          this.paths = [];
        }
        
        // Create new waves
        for (let i = 0; i < this.pathCount; i++) {
          this.randomOffsets[i] = Math.random() * this.offsetRandom;
          this.randomDistances[i] = Math.max(Math.random() * this.maxDistRandom, 0.3);
          this.randomHeights[i] = Math.max(Math.random() + 0.5, 0.3);
          
          // Create Paper.js path
          this.paths[i] = new paper.Path();
          this.paths[i].strokeCap = 'round';
          this.paths[i].strokeColor = this.colors[i % this.colors.length];
          this.paths[i].strokeWidth = this.strokeWidth * this.randomDistances[i];
          
          // Vertical position offset for each wave
          const baseY = this.halfH + (i - this.pathCount/2) * 40;
          
          // Add wave points
          for (let v = 0; v < this.pathPoints; v++) {
            const x = this.w * (v / (this.pathPoints - 1));
            this.paths[i].add(new paper.Point(x, baseY));
          }
          
          // Smooth the path
          this.paths[i].smooth();
        }
      }
      
      animate() {
        paper.view.onFrame = (event) => {
          for (let p = 0; p < this.paths.length; p++) {
            // Loop through path segments
            for (let i = 0; i < this.pathPoints; i++) {
              const segment = this.paths[p].segments[i];
              
              // Cyclic value between -1 and 1
              const timeOffset = event.time * this.speed;
              const positionOffset = (i / this.pathPoints) * this.frequency * this.randomHeights[p];
              const randomOffset = this.randomOffsets[p];
              
              const sinus = Math.sin(timeOffset + positionOffset + randomOffset);
              
              // Y position variation based on wave index
              const baseY = this.halfH + (p - this.pathCount/2) * 40;
              const waveAmplitude = this.h * this.magnitude * this.randomHeights[p];
              
              // Change segment Y position
              segment.point.y = baseY + sinus * waveAmplitude;
            }
            
            // Smooth the path every frame
            this.paths[p].smooth();
          }
        };
      }
      
      resize() {
        this.h = window.innerHeight;
        this.w = window.innerWidth;
        this.halfH = this.h * 0.5;
        
        // Resize Paper.js canvas
        paper.view.viewSize = new paper.Size(this.w, this.h);
        
        // Recreate waves with new dimensions
        this.createWaves();
      }
      
      setupEvents() {
        window.addEventListener('resize', () => {
          this.resize();
        });
        
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            paper.view.pause();
          } else if (!document.hidden) {
            paper.view.play();
          }
        });
      }
    }
    
    /**
     * Particle system as per exact specifications
     */
    class HeroParticles {
      constructor() {
        this.canvas = document.getElementById('particles-canvas');
        if (!this.canvas) {
          console.warn('Canvas particles-canvas not found');
          return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.animationId = null;
        
        // Configuration as per specifications
        this.config = {
          count: this.getParticleCount(),
          colors: ['#FFFFFF', '#B0D2FF', '#D8ECFF'], // Exact colors
          sizes: [1, 1.5, 2, 2.5, 3], // Radius 1-3px
          opacities: [0.4, 0.5, 0.6, 0.7, 0.8], // 40-80%
          bokehChance: 0.05 // < 5% blurred
        };
        
        this.init();
      }
      
      getParticleCount() {
        const baseCount = 150; // Reduced from 300 to 150 for performance
        const screenRatio = (window.innerWidth * window.innerHeight) / (1920 * 1080);
        return Math.floor(baseCount * Math.min(screenRatio, 1.2));
      }
      
      init() {
        this.resizeCanvas();
        this.createParticles();
        this.setupEvents();
        this.animate();
      }
      
      resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
      
      createParticle() {
        const isNearWaves = Math.random() < 0.4; // 40% near waves
        let x, y;
        
        if (isNearWaves) {
          // Distribution concentrated around central waves
          x = Math.random() * this.canvas.width;
          y = this.canvas.height * 0.4 + (Math.random() - 0.5) * 200; // Central area with variation
        } else {
          // Global distribution in space
          x = Math.random() * this.canvas.width;
          y = Math.random() * (this.canvas.height * 0.8);
          
          // Higher density in top right
          if (Math.random() < 0.6) {
            x = this.canvas.width * 0.3 + Math.random() * this.canvas.width * 0.7;
            y = Math.random() * this.canvas.height * 0.5;
          }
        }
        
        return {
          x, y,
          size: this.config.sizes[Math.floor(Math.random() * this.config.sizes.length)],
          color: this.config.colors[Math.floor(Math.random() * this.config.colors.length)],
          baseOpacity: this.config.opacities[Math.floor(Math.random() * this.config.opacities.length)],
          opacity: 0,
          bokeh: Math.random() < this.config.bokehChance,
          drift: {
            x: (Math.random() - 0.5) * 0.2,
            y: (Math.random() - 0.5) * 0.2
          },
          pulse: Math.random() * Math.PI * 2,
          age: 0,
          maxAge: 1000 + Math.random() * 2000,
          shape: Math.random() < 0.3 ? 'hexagon' : 'circle'
        };
      }
      
      createParticles() {
        this.particles = [];
        for (let i = 0; i < this.config.count; i++) {
          this.particles.push(this.createParticle());
        }
      }
      
      updateParticle(particle) {
        particle.age++;
        
        // Slow drift
        particle.x += particle.drift.x;
        particle.y += particle.drift.y;
        
        // Pulsation
        particle.pulse += 0.02;
        const pulseOffset = Math.sin(particle.pulse) * 0.1;
        particle.opacity = Math.max(0.1, Math.min(1, particle.baseOpacity + pulseOffset));
        
        // Fade in/out
        const ageRatio = particle.age / particle.maxAge;
        if (ageRatio < 0.1) {
          particle.opacity *= ageRatio / 0.1;
        } else if (ageRatio > 0.9) {
          particle.opacity *= (1 - ageRatio) / 0.1;
        }
        
        // Recycling
        if (particle.age >= particle.maxAge || 
            particle.x < -50 || particle.x > this.canvas.width + 50 || 
            particle.y < -50 || particle.y > this.canvas.height + 50) {
          Object.assign(particle, this.createParticle());
        }
      }
      
      drawParticle(particle) {
        this.ctx.save();
        this.ctx.globalAlpha = particle.opacity;
        
        // Bokeh effect (sigma=2px as per specifications)
        if (particle.bokeh) {
          this.ctx.filter = 'blur(2px)';
        }
        
        this.ctx.fillStyle = particle.color;
        this.ctx.beginPath();
        
        if (particle.shape === 'hexagon') {
          // Soft hexagonal shape
          const sides = 6;
          const angle = Math.PI * 2 / sides;
          this.ctx.moveTo(
            particle.x + particle.size * Math.cos(0),
            particle.y + particle.size * Math.sin(0)
          );
          for (let i = 1; i <= sides; i++) {
            this.ctx.lineTo(
              particle.x + particle.size * Math.cos(i * angle),
              particle.y + particle.size * Math.sin(i * angle)
            );
          }
        } else {
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        }
        
        this.ctx.fill();
        this.ctx.restore();
      }
      
      animate() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.particles.forEach(particle => {
          this.updateParticle(particle);
          this.drawParticle(particle);
        });
        
        this.animationId = requestAnimationFrame(this.animate.bind(this));
      }
      
      setupEvents() {
        window.addEventListener('resize', () => {
          this.resizeCanvas();
          this.config.count = this.getParticleCount();
          this.createParticles();
        });
        
        document.addEventListener('visibilitychange', () => {
          if (document.hidden && this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          } else if (!document.hidden && !this.animationId) {
            this.animate();
          }
        });
      }
    }
    
    // Initialization
    try {
      window.fluidWaves = new FluidWaves();
      window.heroParticles = new HeroParticles();
      console.log('✅ Hero Background with fluid waves successfully initialized');
    } catch (error) {
      console.warn('⚠️ Error during Hero Background initialization:', error);
    }
  });
} else {
  console.log('⚠️ Animations disabled (prefers-reduced-motion)');
}
</script>
