<!-- Hero Background - Deep Space Aesthetic with Luminous Ribbon -->
<div id="hero-background" class="hero-background">
  <!-- Canvas for particles -->
  <canvas id="particles-canvas"></canvas>
  
  <!-- SVG masks for organic shapes -->
  <svg style="position: absolute; width: 0; height: 0;" aria-hidden="true">
    <defs>
      <mask id="organic-mask-1">
        <path d="M 0,0 L 100,0 Q 90,15 100,30 Q 85,45 100,60 Q 95,75 100,90 L 100,100 L 0,100 Q 15,85 0,70 Q 25,55 0,40 Q 10,25 0,10 Z" fill="white" transform="scale(5,0.8)"/>
      </mask>
      <mask id="organic-mask-2">
        <path d="M 0,0 L 100,0 Q 95,20 100,35 Q 80,50 100,65 Q 92,80 100,95 L 100,100 L 0,100 Q 20,80 0,65 Q 30,50 0,35 Q 8,20 0,5 Z" fill="white" transform="scale(5,0.8)"/>
      </mask>
      <mask id="organic-mask-3">
        <path d="M 0,0 L 100,0 Q 88,25 100,40 Q 78,55 100,70 Q 90,85 100,100 L 0,100 Q 22,75 0,60 Q 35,45 0,30 Q 12,15 0,0 Z" fill="white" transform="scale(5,0.8)"/>
      </mask>
    </defs>
  </svg>

  <!-- Canvas for fluid waves Paper.js -->
  <canvas id="waves-canvas"></canvas>
</div>

<!-- Script for fluid waves Paper.js and particles -->
{{- $paperjs := resources.Get "js/paper-full.min.js" -}}
<script src="{{ $paperjs.RelPermalink }}"></script>
<script>
// Check if animations are allowed
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

if (!prefersReducedMotion) {
  document.addEventListener('DOMContentLoaded', function() {
    
    /**
     * Fluid waves system inspired by Paper.js
     */
    class FluidWaves {
      constructor() {
        this.canvas = document.getElementById('waves-canvas');
        if (!this.canvas) {
          console.warn('Canvas waves-canvas not found');
          return;
        }
        
        // Initialize Paper.js
        paper.setup(this.canvas);
        
        // Waves configuration
        this.h = window.innerHeight;
        this.w = window.innerWidth;
        this.halfH = this.h * 0.5;
        this.speed = 0.12; // Slower for smoothness
        this.strokeWidth = 70;
        this.frequency = 3;
        this.pathCount = 7; // More waves
        this.pathPoints = 24; // More points for smoothness
        
        this.paths = [];
        this.offsetRandom = 3;
        this.randomOffsets = [];
        this.maxDistRandom = 1.2;
        this.randomDistances = [];
        this.randomHeights = [];
        this.magnitude = 0.15; // Wave amplitude
        
        this.readColors();
        
        this.init();
        this.observeTheme();
      }
      
      readColors() {
        const cs = getComputedStyle(document.documentElement);
        const isLight = document.documentElement.getAttribute('data-theme') === 'light';
        this.colors = [1,2,3,4,5,6,7].map(i => {
          let c = cs.getPropertyValue(`--hero-wave-color-${i}`).trim();
          if (isLight) {
            // If color provided without explicit alpha (rgb), add a higher alpha
            if (/^rgb\(\s*\d+/.test(c) && !/rgba/.test(c)) {
              c = c.replace(/^rgb\((.*)\)$/,'rgba($1,0.85)');
            } else if (/rgba\(/.test(c)) {
              // slightly increase existing alpha
              c = c.replace(/rgba\((\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,)([^)]+)\)/, (m,prefix,a)=> {
                let val=parseFloat(a); if(isNaN(val)) return m; return `rgba(${prefix}${Math.min(1,val+0.25)})`; });
            }
          }
          return c;
        }).filter(Boolean);
      }
      
      observeTheme() {
        const observer = new MutationObserver(muts => {
          for (const m of muts) {
            if (m.attributeName === 'data-theme') {
              this.readColors();
              
              // Recolor existing paths
              this.paths.forEach((p, idx) => { p.strokeColor = this.colors[idx % this.colors.length]; });
            }
          }
        });
        observer.observe(document.documentElement, { attributes: true });
        this.themeObserver = observer;
      }
      
      init() {
        this.createWaves();
        this.setupEvents();
        this.animate();
      }
      
      createWaves() {
        // Clean up old waves
        if (this.paths.length > 0) {
          this.paths.forEach(path => path.remove());
          this.paths = [];
        }
        
        // Create new waves
        for (let i = 0; i < this.pathCount; i++) {
          this.randomOffsets[i] = Math.random() * this.offsetRandom;
          this.randomDistances[i] = Math.max(Math.random() * this.maxDistRandom, 0.3);
          this.randomHeights[i] = Math.max(Math.random() + 0.5, 0.3);
          
          // Create Paper.js path
          const path = new paper.Path();
          path.strokeCap = 'round';
          path.strokeColor = this.colors[i % this.colors.length];
          path.strokeWidth = this.strokeWidth * this.randomDistances[i];
          
          // Vertical position offset for each wave
          const baseY = this.halfH + (i - this.pathCount/2) * 40;
          
          // Add wave points
          for (let v = 0; v < this.pathPoints; v++) {
            const x = this.w * (v / (this.pathPoints - 1));
            path.add(new paper.Point(x, baseY));
          }
          
          // Smooth the path
          path.smooth();
          this.paths[i] = path;
        }
      }
      
      animate() {
        paper.view.onFrame = (event) => {
          for (let p = 0; p < this.paths.length; p++) {
            // Loop through path segments
            for (let i = 0; i < this.pathPoints; i++) {
              const segment = this.paths[p].segments[i];
              
              // Cyclic value between -1 and 1
              const timeOffset = event.time * this.speed;
              const positionOffset = (i / this.pathPoints) * this.frequency * this.randomHeights[p];
              const randomOffset = this.randomOffsets[p];
              
              const sinus = Math.sin(timeOffset + positionOffset + randomOffset);
              
              // Y position variation based on wave index
              const baseY = this.halfH + (p - this.pathCount/2) * 40;
              const waveAmplitude = this.h * this.magnitude * this.randomHeights[p];
              
              // Change segment Y position
              segment.point.y = baseY + sinus * waveAmplitude;
            }
            
            // Smooth the path every frame
            this.paths[p].smooth();
          }
        };
      }
      
      resize() {
        this.h = window.innerHeight;
        this.w = window.innerWidth;
        this.halfH = this.h * 0.5;
        
        // Resize Paper.js canvas
        paper.view.viewSize = new paper.Size(this.w, this.h);
        
        // Recreate waves with new dimensions
        this.createWaves();
      }
      
      setupEvents() {
        window.addEventListener('resize', () => {
          this.resize();
        });
        
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            paper.view.pause();
          } else if (!document.hidden) {
            paper.view.play();
          }
        });
      }
    }
    
    /**
     * Particle system as per exact specifications
     */
    class HeroParticles {
      constructor() {
        this.canvas = document.getElementById('particles-canvas');
        if (!this.canvas) {
          console.warn('Canvas particles-canvas not found');
          return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.animationId = null;
        
        // Configuration as per specifications
        this.config = {
          count: this.getParticleCount(),
          colors: ['#FFFFFF', '#B0D2FF', '#D8ECFF'], // Exact colors
          sizes: [1, 1.5, 2, 2.5, 3], // Radius 1-3px
          opacities: [0.4, 0.5, 0.6, 0.7, 0.8], // 40-80%
          bokehChance: 0.05 // < 5% blurred
        };
        
        this.init();
      }
      
      getParticleCount() {
        const baseCount = 150; // Reduced from 300 to 150 for performance
        const screenRatio = (window.innerWidth * window.innerHeight) / (1920 * 1080);
        return Math.floor(baseCount * Math.min(screenRatio, 1.2));
      }
      
      init() {
        this.resizeCanvas();
        this.createParticles();
        this.setupEvents();
        this.animate();
      }
      
      resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
      
      createParticle() {
        const isNearWaves = Math.random() < 0.4; // 40% near waves
        let x, y;
        
        if (isNearWaves) {
          // Distribution concentrated around central waves
          x = Math.random() * this.canvas.width;
          y = this.canvas.height * 0.4 + (Math.random() - 0.5) * 200; // Central area with variation
        } else {
          // Global distribution in space
          x = Math.random() * this.canvas.width;
          y = Math.random() * (this.canvas.height * 0.8);
          
          // Higher density in top right
          if (Math.random() < 0.6) {
            x = this.canvas.width * 0.3 + Math.random() * this.canvas.width * 0.7;
            y = Math.random() * this.canvas.height * 0.5;
          }
        }
        
        return {
          x, y,
          size: this.config.sizes[Math.floor(Math.random() * this.config.sizes.length)],
          color: this.config.colors[Math.floor(Math.random() * this.config.colors.length)],
          baseOpacity: this.config.opacities[Math.floor(Math.random() * this.config.opacities.length)],
          opacity: 0,
          bokeh: Math.random() < this.config.bokehChance,
          drift: {
            x: (Math.random() - 0.5) * 0.2,
            y: (Math.random() - 0.5) * 0.2
          },
          pulse: Math.random() * Math.PI * 2,
          age: 0,
          maxAge: 1000 + Math.random() * 2000,
          shape: Math.random() < 0.3 ? 'hexagon' : 'circle'
        };
      }
      
      createParticles() {
        this.particles = [];
        for (let i = 0; i < this.config.count; i++) {
          this.particles.push(this.createParticle());
        }
      }
      
      updateParticle(particle) {
        particle.age++;
        
        // Slow drift
        particle.x += particle.drift.x;
        particle.y += particle.drift.y;
        
        // Pulsation
        particle.pulse += 0.02;
        const pulseOffset = Math.sin(particle.pulse) * 0.1;
        particle.opacity = Math.max(0.1, Math.min(1, particle.baseOpacity + pulseOffset));
        
        // Fade in/out
        const ageRatio = particle.age / particle.maxAge;
        if (ageRatio < 0.1) {
          particle.opacity *= ageRatio / 0.1;
        } else if (ageRatio > 0.9) {
          particle.opacity *= (1 - ageRatio) / 0.1;
        }
        
        // Recycling
        if (particle.age >= particle.maxAge || 
            particle.x < -50 || particle.x > this.canvas.width + 50 || 
            particle.y < -50 || particle.y > this.canvas.height + 50) {
          Object.assign(particle, this.createParticle());
        }
      }
      
      drawParticle(particle) {
        this.ctx.save();
        this.ctx.globalAlpha = particle.opacity;
        
        // Bokeh effect (sigma=2px as per specifications)
        if (particle.bokeh) {
          this.ctx.filter = 'blur(2px)';
        }
        
        this.ctx.fillStyle = particle.color;
        this.ctx.beginPath();
        
        if (particle.shape === 'hexagon') {
          // Soft hexagonal shape
          const sides = 6;
          const angle = Math.PI * 2 / sides;
          this.ctx.moveTo(
            particle.x + particle.size * Math.cos(0),
            particle.y + particle.size * Math.sin(0)
          );
          for (let i = 1; i <= sides; i++) {
            this.ctx.lineTo(
              particle.x + particle.size * Math.cos(i * angle),
              particle.y + particle.size * Math.sin(i * angle)
            );
          }
        } else {
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        }
        
        this.ctx.fill();
        this.ctx.restore();
      }
      
      animate() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.particles.forEach(particle => {
          this.updateParticle(particle);
          this.drawParticle(particle);
        });
        
        this.animationId = requestAnimationFrame(this.animate.bind(this));
      }
      
      setupEvents() {
        window.addEventListener('resize', () => {
          this.resizeCanvas();
          this.config.count = this.getParticleCount();
          this.createParticles();
        });
        
        document.addEventListener('visibilitychange', () => {
          if (document.hidden && this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          } else if (!document.hidden && !this.animationId) {
            this.animate();
          }
        });
      }
    }
    
    // Initialization
    try {
      window.fluidWaves = new FluidWaves();
      window.heroParticles = new HeroParticles();
      console.log('✅ Hero Background with fluid waves successfully initialized');
    } catch (error) {
      console.warn('⚠️ Error during Hero Background initialization:', error);
    }
  });
} else {
  console.log('⚠️ Animations disabled (prefers-reduced-motion)');
}
</script>
